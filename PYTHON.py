# Типы данных

# Изменяемые (mutable)
# print(type(  {1, 1, "a"}     )) # -> set  Множество
# print(type(  {"a":1, 2:"b"}  )) # -> dict Словарь
# print(type(  [1, 1, "a"]     )) # -> list Список
# from array import array
# print(type(  array("l", [1, 1, 2])  )) # -> array Массив

# Неизменяемые (not mutable)
# print(type(  "abc"        )) # -> str      Строка
# print(type(  (1, 1, "a")  )) # -> tuple    Кортеж
# print(type(  None         )) # -> NoneType Отсутствие данных
# print(type(  True         )) # -> bool     Логическое значение
# print(type(  1            )) # -> int      Целое число
# print(type(  1.4          )) # -> float    Число с плавающей точкой
# print(type(  1 + 1j       )) # -> complex  Комплексное число
# print(type(  frozenset([1, 1, "a"])  )) # -> frozenset неизменяемое множество


# print(complex(2, 3j)) # создание комплексного числа

# Узнать айди объекта
# print(id('строка'))
# print(id([1, 2, 3]))

# узнать адресс в памяти в шестнадцатеричном формате
# print(hex(id('строка')))
# print(hex(id([1, 2, 3])))

# print("52 =", bytes(52)) # Преобразует объект в неизменяемую строку байтов
# print("Привет Мир! =", bytes('Привет Мир!', encoding='utf-8'))

# print("52 =", bin(52)) # преобразует целое число в двоичную (бинарную) строку с префиксом '0b'
# print("52 =", bin(52))[2:]

# изменяемый объект (id объекта всегда один и тот же)
# x = [1, 2, 3]
# print(id(x), x)
# x[2] = 6
# print(id(x), x)
# x.append(8)
# print(id(x), x)

# неизменяемый объект (но добавление нового элемента а не изменение не меняет id объекта)
# y = '123'
# print(id(y), y)
# y = y[:2] + '6'
# print(id(y), y)
# y += '8'
# print(id(y), y)

# Области видимости (Пространства имен)
# built-in # встроенные функции в интерпретаторе, для их использования не надо импортировать модули, а так же операторы (зарезервированные слова).
# global   # объекты доступные в пространстве имён модуля.
# local    # объекты доступные внутри функции.
# nonlocal # делает доступной переменную в блоке внешней функции (обёртки).

# def a():
#     ''' документация функции "a" '''
# class b:
#     ''' документация класса "b" '''
#     def MY_METHOD_MY_METHOD_MY_METHOD_MY_METHOD_MY_METHOD():
#         pass
# print('Имя объекта:', a.__name__, b.__name__) # позволяет посмотреть имя объекта
# print('Документация объекта:', a.__doc__, b.__doc__) # позволяет посмотреть документацию объекта
# print(help(a)) # позволяет посмотреть документацию объекта
# print(globals()) # показывает доступные объекты в пространстве имён модуля
# import math
# print(dir(math)) # позволяет узнать какие объекты содержаться в функции/модуле (без аргументов в текущем пространстве имён модуля)
# print(dir(b))
# print(__name__) # узнать какое состояние имеет переменная __name__ в текущем пространстве имён модуля

# print(callable(len), callable('строка')) # проверяем является ли объект вызываемым

# print(locals()) # возвращает словарь с переменными и их значениями из текущей локальной области видимости в виде словаря

# принадлежность объекта к конкретному классу можно проверить функцией isinstance
# 1арг. объект который мы хотим проверить, 2арг. класс (или кортеж классов) к которому они должны принадлежать, вернёт True/False
# print(isinstance('строка', int))
# print(isinstance('строка', str))
# # либо тоже самое с помощью класса type()
# print(type('строка') == int)
# print(type('строка') == str)

# принадлежность объекта к конкретному субклассу можно проверить функцией isinstance
# 1арг. тип к которому должен принадлежать объект который мы хотим проверить, 2арг. тип (или кортеж типов) проверяемых объектов, вернёт True/False
# print(issubclass(int, type(72)))
# print(issubclass(int, type("Hello World!")))
# print(issubclass(str, type("Hello World!")))

# функция type определяет тип данных
# if type(True) == bool :
# 	print("bool")
# if type(1) == int :
# 	print("int")

# функция bool преобразует числовое значение в истину или ложь
# если число 0 значит ложь, если число больше или меньше 0 то истина
# print(bool(11))
# print(bool(-11))
# print(bool(0))
# так же работает и со строками, только в качестве лжи применяется пустая строка
# print(bool('a'))
# print(bool(''))
# так же и с коллекциями
# print(bool([1, 2]))
# print(bool([]))

# умножение разных типов данных
# print(1*5)
# print('1'*5) # строка
# print([[]]*5) # список
# print((1,)*5) # кортеж
# print(True*5, 1*5) # булевые
# print(False*5, 0*5)

# булевые значения можно суммировать если они суммируются в integer object
#         1     1      0      1     0
# array = [True, True, False, True, False]
# int_count = 0
# for bool_value in array:
#     int_count += bool_value
# print(int_count, sum(array))

# print(hash('string')) # хэш можно найти только у неизменяемых типов данных
# print(hash([1, 2, 3])) # TypeError: unhashable type: 'list'

# код можно писать в одну строку с помощью точки с запятой ';'
# a = 1; b = 2; c = [1, 2]
# print(a, b, c)

# по умолчанию print разделяет аргументы одиночными пробелами
# но при помощи параметра sep можно указать другой разделитель
# print('a', 'b', 'c', sep='111')

# параметр end может склеивать принты вместе
# print('a', 'b', 'c', end=' ')
# print('d', 'e', 'f')

# читабельный вывод словарей с табуляцией
# import json
# print(json.dumps(словарь, indent=4, ensure_ascii=False))

# перевод числового значения int или float в строку с помощью метода str()
# a = 5
# b = 5.7
# c = 'Строка с числом ' + str(a) + str(b)
# print(c)

# функция input запрашивает данные для ввода и передаёт их в строке
# функция int переводит строковые значения(цифровые) в целые числа
# функция float переводит строковые значения(цифровые) в числа с плавающей точкой
# a = input("Введите число:\n")
# b = int(a) + 5
# b = float(a) + 5
# print(b)

# a = float(input("Введите число: "))
# b = float(input("Введите число: "))
# print("Результат:", a + b)
# print("Результат:" + str(a + b)) # объединение строки с числом

# # eval() может выполнить лишь выражение Python.
# print(eval("1024 + 1024"))
# print(eval("sum([8, 16, 32])"))
# print(eval("min([1, 2, 3])"))
# print(eval("[i for i in range(5)]"))
# x, y = 7, 7
# print(eval("x != y")) # в eval можно передавать глобальные переменные
# print(eval("x != y", {"x": 7})) # в eval можно указать только определенные переменные в формате словаря которые должны попасть в функцию.
# # compile() можно использовать для предоставления объектов кода для eval() вместо обычных строк.
# code = compile("5 + 4", "<string>", "eval")
# print(eval(code))
# # exec() может выполнить любой фрагмент кода Python.
# exec("if 1 > 0: print('да, 1 больше 0')")

# Операторы условий
# if
# elif
# else
# :
# pass # оператор заглушка, допустим что бы не писать print() или кавычки документации ''' '''
# ... # так же работает как заглушка
# del # оператор удаления объекта

# Логические операторы (имеют приоритет выполнения)
# not # первый
# and # второй
# or  # третий

# continue # оператор для работы с циклами, пропускает итерацию и начинает следующую с самого начала
# break # оператор для работы с циклами, останавливает цикл и выходит из тела цикла
# else # оператор в том числе и для работы с циклами, сработает только в том случае
# если цикл завершиться сам по себе, то есть выполнит все итерации

# i = 0
# print('>>> IN')
# while i < 10:
#     i += 1
#     if i > 3 and not i > 6: # если i больше 3 и i не меньше 6 тогда пропускаем итерацию
#         print('i =', i, 'continue')
#         continue
#     print('i =', i)
#     if i == 8:
#         print('i =', i, 'break')
#         break
# else:
#     print('сработал оператор else')
# print('>>> OUT')

# Убираем повторяющиеся элементы из списка с помощью цикла
# a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
# b = []
# for i in a:
#     if not i in b:
#         b.append(i)
# print(a)
# print(b)

# сортировка строки по маленьким/большим буквам и не буквенным символам с помощью цикла
# s = 'h@lLo WOrld!'
# for i in s:
#     if i >= 'a' and i <= 'z':
#         print(i, 'small')
#     elif 'A' <= i <= 'Z':
#         print(i, 'big')
#     else:
#         print(i, 'не буквенный символ')

# подсчёт количества повторяющихся букв в строке с помощью циклов
# s = 'abczjhdf HG jgkfYGg jhgkdf 543 *(^($&*#'
# letters = [0] * 26
# for i in s.lower():
#     if i >= 'a' and i <= 'z':
#         number = ord(i) - 97
#         letters[number] += 1
# for i in range(26):
#     if letters[i] > 0:
#         print(chr(i + 97), letters[i])

# Операторы сравнений (Проверяют объекты на равенство их значений)
# ==
# <
# >
# <=
# >=
# !=

# построение диапазона с помощью операторов сравнений
# number = 4
# if 3 <= number <= 6:
# # if number >= 3 and number <= 6: # аналогичная запись
#     print('число в диапазоне от 3 до 6')

# операторы сравнения можно записывать в цепочке
# a, b, c, d = 1, 1, 1, 1
# if a == b == c == d:
#     print('все числа равны')

# оператор 'in' если часть объекта равна возвращает логическое значение True иначе False
# link1 = 'https://'
# link2 = 'https://#'
# link3 = 'https://www.youtube.com'
# print(link1 in link3) # True
# print(link2 in link3) # False

# оператор 'is' если объекты ссылаются на одну и туже ячейку в памяти то возвращает логическое значение True иначе False
# x = 10
# y = 10
# print(x is y) # True

# для слишком больших чисел выделяется отдельная область в памяти
# x = 31**25
# y = 31**25
# print(x, x is y) # True
# a = 26**26
# b = 26**26
# print(a, a is b) # False

# для списков выделяется отдельная область в памяти
# x = [1, 2, 3]
# y = x
# z = [1, 2, 3]
# print(x is y) # True
# print(y is z) # False
# print(x is z) # False

# float('inf') считается самым большим числом в python, он действует как неограниченное верхнее значение для сравнения
# print(float('inf') > 99999**99999) # True

# Математические операторы (имеют приоритет выполнения)
# a = 10 + 5
# a = 10 - 5
# a = 10 * 5
# a = 19 / 5 # обычное деление, ответ = 3.8
# a = 19 // 5 # деление с отбросом остатка после точки (в числе 19 число 5 помещается 3 раза)

# Остаток от деления 19 % 7 в число 19 число семь помещается 2 раза, остаток = 5

# Так же можно находить числа кратные числу, например найти числа кратные 4 в последовательности чисел
# for n in range(21):
#     if n % 4 == 0:
#         print(n)

# a = число % 2 # узнаём есть ли остаток после точки при делении
# возвращает 0 если остатка нет, 1 если остаток есть (можно вычислять четные или не четные числа)

# for n in range(1, 11):
#     if n % 2 == 0:
#         stri = 'Четное'
#     else:
#         stri = 'Не четное'
#     print(f'Число: {n} {stri}')

# a = 6 ** 3 # возведение в степень (аналог 6*6*6)
# унарный минус
# a = 10
# a = -a # из положительного в отрицательное значение
# a = -a # из отрицательного в положительное значение
# print(a)

# Операции с числами
# print(sum( [10, 7, 2, 15] )) # функция sum() складывает все числовые значения из списка
# print(abs(-13.2)) # функция abs() переводит число из отрицательного в положительное
# print(min(16,9,-3,42,25)) # возвращает минимальное число
# print(max(90,4,-2,54,63)) # возвращает максимальное число
# print(pow(16, 7), 16**7) # функция pow() возводит число в степень
# округление числа с плавающей точкой
# print(round(5.758, 1)) # округление от середины # так же может иметь 2 арг. который будет указывать с какой точки начинать округлять
# import math
# print(math.ceil(5.7)) # округление всегда в большую сторону
# print(math.floor(5.7)) # округление всегда в меньшую сторону
# print(math.trunc(54.748)) # обрезает знаки после точки оставляя только целое число # точно так же работает int(54.748)
# print("pi =", math.pi) # число пи

# для разделения математических операций по приоритету используются круглые скобки
# приоритет на примере
# # 7   5   6   4   3     2     1
# y = x + 7 > x + 2 * (x ** (3 ** x) )

# Арифметическая прогрессия
# a = int(input()) # 1  # 100
# b = int(input()) # 1  # 50
# c = int(input()) # 10 # 1
# x = a + b * (c - 1)
# print(x)

# Геометрическая прогрессия
# a = int(input()) # 1 # -2
# b = int(input()) # 2 # 10
# c = int(input()) # 5 # 3
# x = a * b ** (c - 1)
# print(x)

# разделение числа посимвольно с помощью математических операторов, замена срезам/индексации строк
# a = 1234
# n1 = a // 1000 # для первой цифры можно не использовать остаток от деления
# n2 = a // 100 % 10
# n3 = a // 10 % 10
# n4 = a // 1 % 10
# print(n1, n2, n3, n4, sep='   ')

# операции присваивания в пайтон
# a += b прибавляем a к b (аналог a = a + b)
# a -= b (аналог a = a - b)
# a *= b (аналог a = a * b)
# a /= b (аналог a = a / b)
# a //= b (аналог a = a // b)
# a %= b (аналог a = a % b)
# a &= b (аналог a = a & b)

# программа открывающая сайт https://www.youtube.com
# input не пропускает цикл пока пользователь не введёт какие либо данные
# import os
# while True :
# 	sayt = input("Введите адрес сайта:\n")
# 	if sayt == "завершить" :
# 		break
# 	if "https://" in sayt :
# 		os.system("start " + sayt)
# 		print("if")
# 	elif "www." in sayt :
# 		sayt = "https://" + sayt
# 		os.system("start " + sayt)
# 		print("elif")
# 	else :
# 		sayt = "https://www." + sayt
# 		os.system("start " + sayt)
# 		print("else")

# import time
# import os
# time.sleep(3)
# os.system("start https://www.youtube.com")
# time.sleep(3)
# os.system("start https://www.twitch.tv")
# time.sleep(3)
# os.startfile("C:\Program Files\CPUID\CPU-Z\cpuz.exe")

# полностью очистить терминал
# import os
# os.system('cls') # для windows
# os.system('clear') # для linux/mac

# модуль рандом
# import random
# print(random.randrange(1, 100))

# while оператор цикла исполняется (пока условие верно)
# цикл от 1 до 5
# можно подключить оператор else который сработает по завершению цикла
# a = 0
# while a < 5 :
# 	a += 1
# 	print(a)
# else :
# 	print("finish")

# while True :
# 	a = int(input())
# 	b = 1
# 	count = 0
# 	while count < a :
# 		count += 1
# 		b *= count
# 	else :
# 		print("result:", b)

# while True :
# 	a = ""
# 	while len(a) < 5 :
# 		b = input("Ввод данных: ")
# 		if b == "o" :
# 			continue # игнорируем символ
# 		if b == "t" :
# 			break # прерываем цикл
# 		a += b
# 	else :
# 		print("result:", a)
# 	print(">>> Сброс программы <<<")

# цикл for

# basket = [1,2,3,4,5,6]
# # спискам в цикле можно применять метод среза тем самым укоротив цикл до 3 итераций
# for i in basket[:3]:
#     print(i)

# можно подключить оператор else который сработает по завершению цикла
# ищем конкретные символы
# a = "test text"
# count = 0
# for i in a :
# 	if i == "t" :
# 		print("найдено совпадение:", i)
# 		count += 1
# 	if i == "x" :
# 		break
# else :
# 	print("result:", i, "=", count)

# пропускаем символы
# a = "test text"
# count = 0
# for i in a :
# 	if i == "t" :
# 		continue
# 	print(i)
# else :
# 	print("result:", i, "=", count)

# подсчёт количества повторяющихся символов
# while True :
# 	a = "йцукенгшщзхъфывапролджэячсмитьбю0123456789"
# 	b = input("Введите строку:\n")
# 	for i in a :
# 		count = 0
# 		for index in b :
# 			if i == index :
# 				count += 1
# 		if count > 0 :
# 			# idk :D
# 			if count == 2 or count == 3 or count == 4 or count == 22 or count == 23 or count == 24 :
# 				name = "раза"
# 			else :
# 				name = "раз"
# 			print("буква", '"' + i + '"', "попалась", count, name)

# функция range принимает аргументы (start, end, step)
# for i in range(3, 16, 2) :
# 	print(i)
# for i in range(10, -1, -1): # обратная последовательность от 10 до 0
#     print(i)
# for i in range(-10, 0): # отрицательная последовательность от -10 до -1
#     print(i)


# итерация элементов в итерируемом объекте с помощью функций iter, next
# r = range(4)
# # print(r, type(r)) # range(0, 4) <class 'range'>
# # r = [0, 1, 2, 3]
# # print(r, type(r)) # [0, 1, 2, 3] <class 'list'>

# it = iter(r)
# # it = r.__iter__() # тоже самое просто другой синтаксис
# # print(it, type(it)) # <range_iterator object at 0x0000027F539A9810> <class 'range_iterator'>

# n1 = next(it)
# n2 = next(it)
# n3 = next(it)
# n4 = it.__next__() # тоже самое просто другой синтаксис

# print(n1, n2, n3, n4)
# Если элементы закончатся и ещё раз вызвать next то сработает исключение StopIteration


# a = [5, 6, 7]
# b = [100, 200, 300, 400]

# # объект итератор zip упаковывает в кортеж значения стоящие на одинаковых индексах в двух и более списках
# zp = zip(a, b)
# print('zip:', zp, list(zp))

# # тоже самое только с помощью цикла
# lst = []
# for i in range(min(len(a), len(b))):
#     lst.append((a[i], b[i]))
# print('lst:', lst)

#########################################################################################
# Список (list) упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#########################################################################################

# индексация с конца            -4              -3                -2               -1
# индексация с начала            0               1                 2                3
# xxxxxxxxxxxxxxxxxxxxx = ['Выпить кофе', 'Изучить Python', 'Захватить мир', 'Купить хлеба']

# узнать длинну списка можно с помощью функции len(имя списка)
# в питон есть обратная индексация с конца к началу с помощью знака - вместо нуля идёт -1 и т.д.
# a = [4, 2, 33, "строка", 5, ["a", "b", 16] ]
# print(a[0])
# без исключения обратится к последнему элементу списка (если он пустой):
# lst = []
# a = lst[-1:] or None
# print(a)
# можно обращатся к вложенным спискам внутри списка таким способом
# print(a[-1][1])
# можно перезаписывать определённую ячейку из списка
# a[0] = 7
# print(a[0])
# можно менять данные в списке или списках местами множественным присваиванием # https://younglinux.info/python/task/exchange
# a[0], a[2] = a[2], a[0]
# print(a[0], a[2])
# можно добавить данные в список
# a = a + [7]
# print(a)
# функция list() разбивает строку по 1 символу и превращает её в список
# a = list("5861cfg")
# print(a)

# сравнение списков (при этом происходит поочередное сравнение каждого элемента списка слева на право)
# print('[1] <= [1]', [1] <= [1])
# print('[2] <= [1]', [2] <= [1])
# print('[1, 1] <= [1, 1]', [1, 1] <= [1, 1])
# print('[1, 2] <= [1, 1]', [1, 2] <= [1, 1])

########################################
# Методы для работы со списками (list) #
########################################

# x = [9, 8, 7, 6, 5]
# print(7 in x[1:3]) # с помощью среза проверяем есть ли данный элемент в списке в промежутке от 1 до 3 индекса
# print(len(x)) # узнать длинну списка
# x.append("kek") # добавляет элемент в конец списка
# x.insert(1, 7) # добавляет элемент перед указанным индексом
# print(x.count(7)) # узнаём сколько одинаковых элементов в списке по имени элемента
# print(x.index(7)) # узнаём индекс элемента в списке по имени элемента (2арг. с какого индекса начинать искать, 3арг. на каком закончить искать)
# x.sort() # сортирует список по возрастанию, если добавить арг. reverse=True список отсортируется по убыванию
# так же у способов sort и sorted имеется второй именованный арг. key=функция для изменения принципа сортировки
# примечание, sort и sorted сортирует как цифры так и каждый символ в строке включая буквы
# c = sorted(x, key=abs) # возвращает новый отсортированный список в формате списка в переменную (родительский не трогает)
# x.reverse() # инвертирует список и перезаписывает его в эту же ячейку памяти (способ без метода x[:] = x[::-1])
# print(reversed('98765')) # создаёт итератор с инвертированными элементами
# (аналогично x = list('98765') x.reverse() print(x))
# x.pop(0) # удаляет элемент по указанному индексу (если указать переменную то сохранит удалённый элемент в переменную)
# по умолчанию без аргумента pop() удаляет элемент в конце списка, является аналогом del список[индекс]
# x.remove(7) # удаляет конкретный элемент в списке по имени элемента
# x.clear() # полностью очищает список
# x.extend(["asd", "gg", 123]) # распаковывает список в конце списка
# c = x.copy() # создаёт копию списка в переменную (аналоги c = x[:] или c = list(x))
# c = ["Hello"]+["Random"]+["Friend"] # списки можно складывать
# print(c)
# print(x)
# new_text = '___'.join(c) # переводим список обратно в строку в качестве пробелов можно указать любой символ
# print(new_text)

# a = list(range(10))
# b = []
# for i in a:
#     if i == 5 or i == 6:
#         continue
#     # b += [i]
#     b.append(i) # аналогично
# else:
#     print(b)

# в списках можно использовать синтаксис срезов так же как и в строках

# a = list(range(1, 21))
# b = []
# если нам нужно скопировать список то используем метод copy()
# c = a.copy()
# либо более точное средство (синтаксис срезов) [start:stop:step]
# c = a[::] # полный список
# c = a[0::2] # заменяем цикл одной строчкой
# c = a[1::2] # заменяем цикл одной строчкой
# c = a[:5]
# c[:2] = ['gg', 'wp'] # заменяем первые 2 элемента на элементы из нового списка
# c[:2] = [] # удаляем первые 2 элемента т.к. заменяем их пустотой, если написать c[:] можно очистить весь список
# так же можно заменять значение по конкретному индексу c[3] = 6
# print(c)

# del c[2] # удалить значение по индексу

# for i in a:
#     if i % 2 == 0:
#         a.remove(i) # из списка a удаляем числа кратные 2 то есть получаем нечетные
#         b.append(i) # в список b записываем только числа кратные 2 то есть четные
# else:
#     print("a:", a)
#     print("b:", b)
#     print("c:", c)

#######################################################################################################
# Кортеж (tuple) неизменяемая упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#######################################################################################################

# x = 1, # создание кортежа без помощи круглых скобок с одним значением и запятой
# print(x)

# x = (9, 8, 7, 6, 5, 4) # создание кортежа, скобки при создании дают наглядное представление что это кортеж
# a, b, c, d, e, f = x # присвоение каждого значения по очереди из кортежа в переменные
# print(a, b, c)

# x = () # создание пустого кортежа при помощи скобок

# x = tuple() # создание пустого кортежа классом tuple
# print(x)

# для заполнения tuple можно использовать любую итерабельную последовательность
# print(tuple([1, 2, 3]), tuple({1, 2, 3}), tuple((1, 2, 3)), tuple('123'))

# кортеж имеет индексацию по аналогии со списками
# print(x[0], x[4])

# хоть кортеж и является не изменным, но если в нём содержится изменяемый тип данных мы может изменить только его
# y = (1, 2, 3, [1, 2], 4)
# y[3].append(7)
# y[3].append(14)
# print(y)

# кортеж можно использовать в качестве ключа для словаря
# a = (1, 2, 3)
# b= {}
# b[a] = 'hello'
# print(b)

# у кортежа очень мало методов, поэтому для его изменения сначало надо
# преобразовать в список, изменить, затем преобразовать обратно в кортеж
# tupl = (9, 8, 7, 6, 5, 4)
# lis = list(tupl)
# lis[0] = 42
# lis.append(31)
# tupl2 = tuple(lis)
# print(tupl2)

# my_tuple = ('python', 'is', 'awesome', 'is')
# print(my_tuple[2]) # обращение к элементу кортежа по индексу
# к кортежам можно применять срез
# print(my_tuple[1:2])

# print(my_tuple + my_tuple) # кортежи можно складывать
# print(my_tuple * 2) # кортежи можно дублировать
# print('is' in my_tuple, 'abcde' in my_tuple) # с помощью in можно проверять находится ли конкретный элемент в кортеже

# функция enumerate превращает каждый элемент списка в кортежи состоящие из индекса и значения
# можем принимать 2арг. в котором указывается с какого индекса начинать отсчёт
# print(list(enumerate([10, 20, 30, 'abcd', '77'], 765)))
# lst = [10, 20, 30, 'abcd', '77']
# strg = 'abcd'
# tpl = (10, 20, 'one', 'two')
# st = {10, 20, 'aa', 'bb'}
# dct = {10:'10', 20:'20', 30:30, 'ade':'eda'}
# for index, value in enumerate(dct):
#     print(index, value)

#########################################
# Методы для работы с кортежами (tuple) #
#########################################

# print(len(my_tuple)) # узнать количество всех элементов в кортеже
# print(my_tuple.count('is')) # узнаём количество элементов по значению
# print(my_tuple.index('is')) # возвращает первый попавшийся индекс искомого элемента (слева на право)
# print(sorted(my_tuple)) # возвращает новый отсортированный список в переменную (родительский не трогает)

################################### Блок Кортежа закончен ###################################

# парсинг файлов
# ('C:\\pyTraining\Тест папка', ['Новая папка (1)', 'Новая папка (2)'], ['Новый текстовый документ 1.txt', 'Новый текстовый документ 2.txt', 'Новый точечный рисунок 1.bmp'])
# import os
# import time
# list = []
# for adress, dirs, files in os.walk("C:\\pyTraining\Тест папка"):
#     # list.append(adress) # пути ко всем папкам
#     for file in files:
#         full = os.path.join(adress, file)
#         # if ".txt" in full:
#         # if time.time() - os.path.getctime(full) < 86400:
#             # list.append(full)
#         # путь ко всем файлам
#         list.append(os.path.join(adress, file))
#     print(list)

######################
# Работа с функциями #
######################

# функция определения калорийности
# def calorie_calculator(name, get_calorie, spend_calorie):
#     if get_calorie > spend_calorie:
#         msg = name + ' getting fat'
#     else:
#         msg = name + ' lose weight'
#     return msg
# print(calorie_calculator('Arseniy', 2000, 2150))
# person = ['Ivan', 1900, 1200]
# # в функцию можно передавать сразу список с помощью спец символа * перед названием списка
# print(calorie_calculator(*person))

# оператор return возвращает значение в точку запуска функции то есть show2()
# def show2():
#     x = 7 + z
#     return x
# z = 4 # переменная должна быть выше точки запуска функции остальное не важно
# y = show2()
# print(y) # взаимодейстовать с переменной x внутри функции можно только через return
# x = show2() + 1
# print(x)
# z = 6
# t = show2()
# print(t)

# можно записывать дефолтные аргументы и задавать им значение
# def count_list(list, boolean = False, count = 0):
#     if boolean == True:
#         typelist = type(list[5]) # узнём тип элемента списка
#         for i in list:
#             count += 1 # узнём сколько элементов в списке
#         return count, typelist

#     else:
#         for i in list:
#             count += 1
#         return count

# j = [9, 8, 7, 6, "a", 0.4, True]

# передали 2 аргумента вернулось 2 аргумента
# h, p = count_list(j, True)
# print(h, p)

# передали 1 аргумент вернулся 1 аргумент
# h = count_list(j)
# print(h)

# Если требуется распаковать больше значений чем указано переменных,
# остальные значения попадут в переменную список со звёздочкой *
# *x2, y2, z2 = 0, 1
# print(x2, y2, z2)
# x1, *y1, z1 = 0, 1
# print(x1, y1, z1)
# x3, y3, *z3 = 0, 1
# print(x3, y3, z3)
# a, b, *c = 0, 1, 2, 3, 4
# print(a, b, c)

# если перед аргументом записать * то все аргументы прописанные после него превратятся в кортеж
# можно записать аргументы после кортежа если указать в вызове имя аргумента вместе со значением
# def name(h, d, *args, key1, key2):
#     print(h)
#     print(d)
#     print(args)
#     print(key1)
#     print(key2)
# name(1, 2, 3, 4, 5, key1=6, key2=7)

# функция возвращает по одному элементу без повторений
# def exclusive_item(*args, key=False):
#     newlist = []
#     for i in args:
#         for y in i:
#             if y not in newlist:
#                 newlist.append(y)
#     if key:
#         newlist.sort()
#     return newlist


# # args = arguments
# def print_ab(a, b, *args):
#     print(a)
#     print(b)
#     print(args)
# # Передача списка с помощью спец символа * разбивает его поэлементно и отправляет каждый
# # элемент в виде отдельного аргумента. (аналог передачи по индексу lst[0], lst[1] и т.д.)
# lst = [10, 20, 30, 40]
# print_ab(*lst)
# # Если не угадать с количеством передаваемых элементов и объявленых аргументов в функции
# # то получим исключение TypeError, что бы не прописывать каждый аргумент в функции, можно
# # воспользоваться спец символом * уже в функции для включения всех полученных элементов в один кортеж

# # kwargs = keyword arguments
# # если между позиционными a, b и запакованными **kwargs стоит слеш то аргументы из **kwargs автоматически не перейдут в a, b
# # def print_ab2(a, b, /, **kwargs):
# def print_ab2(a, b, **kwargs):
#     print(a)
#     print(b)
#     print(kwargs)
# # Таким же способом *dct можно передать ключи словаря, а с помощью двух **dct значения словаря
# # в случае с **dct необходимо явно описывать принимаемые аргументы в функции либо использовать **kwargs
# dct = {'a':10, 'b':20, 'c':30, 'd':40}
# print_ab2(**dct)
# print()
# print_ab2(1, 2, c=10, d=20)


# z = [9,8,7]
# x = [8,8,9,7,6,5]
# c = [1,2,3,4,5,6,7,7]

# t = exclusive_item(z, x, c, key=True)
# print(t)

# x = 5
# def name():
#     global x # пезаписываем глобальную переменную вне функции
#     x += 10
#     print(x)
# name()
# print(x)

# x = 5
# def name():
#     x = 10
#     def name2():
#         nonlocal x # аналог global но использовать можно только во вложенной функции
#         x = 100
#         print(x)
#     name2()
#     print(x)
# name()
# print(x)

# Вычисляем объем цилиндра
# import math
# # константы правильно записывать в верхнем регистре
# PI = math.pi

# def radius():
#     n = float(input("Введите диаметр цилиндра в см: "))
#     n /= 2
#     return n

# def height():
#     m = float(input("Введите высоту цилиндра в см: "))
#     return m

# def volume():
#     r = radius()
#     h = height()
#     s = PI * r ** 2
#     v = s * h
#     return v
# print("Объем цилиндра:", volume(), "см3")

# def massa(g):
#     n = float(input("Удельный вес г/см3: "))
#     return g * n / 1000
# print("Вес цилиндра в кг:", massa(volume()))

##################################################################################################
# Словарь (dict) изменяемая неупорядоченная коллекция произвольных элементов с доступом по ключу #
# иногда ещё называют ассоциативным списком или хеш-таблицей.                                   #
# в словаре данные всегда привязаны к ключу                                                      #
#                                                                                                #
# ключём в словаре могут быть только неизменяемые типы данных,                                   #
# если в кортеже содержится изменяемый тип данных то кортеж не может быть ключём.                #
##################################################################################################

# d = {}
# tpl = ((1, 2, (1, 2, [1, 2])), 1, 2)
# # для ключа словаря можно использовать только полностью не изменяемые типы данных
# # даже глубоко вложенный изменяемый тип данных - список - вызовет ошибку: TypeError: unhashable type: 'list'
# d[tpl] = 'test'

# dict1 = {}
# not_mutalbe_tuple = (4, True)
# dict1[not_mutalbe_tuple] = 'текст'
# print(dict1)
# mutable_tuple = (4, [1, 2])
# dict1[mutable_tuple] = 'текст' # TypeError: unhashable type: 'list'

# d1 = {} # создаём пустой словарь
# d1 = dict() # способ с помощью функции

# d2 = {'name':'Arseniy', 'lang':'ru'}
# d3 = dict(name='Arseniy', lang='ru')
# print(d2, d3)

# d1 = {'a':7}
# print(d1['a']) # вызов по ключу, ключ 'a' значение 7
# d1['b'] = 9 # добавление пары ключ:значение в конец словаря (если такого ключа ещё не сущестует)
# d1['a'] = 4 # изменение значения по ключу (если такой ключ уже существует)
# del d1['b'] # удаление элемента по ключу
# print(d1)

# print(dict(raz=7, dva=9)) # создание словаря с парой ключ:значение
# print(dict([[1, 'один'], [2, 'два'], [3, 'три']])) # иной способ создание пар

# Заменяем ключ в словаре
# new_dict = { str(k).replace(str('какой_то_ключ'), 'заменяем_на_этот_ключ'): v for k, v in old_dict.items() }

# при сравнении словарей сравниваются как ключи так и их значения
# d1 = {'a':4, 'b':4}
# d2 = {'a':4, 'b':4}
# d3 = {'a':4, 'b':3}
# print(d1 == d2, d1 == d3)

# сравнить только ключи
# print(d1.keys() == d2.keys(), d1.keys() == d3.keys())

#########################################
# Методы для работы со словарями (dict) #
#########################################

# https://stackoverflow.com/questions/18552001/accessing-dict-keys-element-by-index-in-python3

# d1 = {1:'one', 2:'two', 3:'three', 4:'four'}

# print(dict.fromkeys([1, 2, 3, 4, 5], 'значение')) # задаём одно значение для ряда ключей
# d1.clear() # удаляет всё из словаря

# print(d1.get('ключ')) # тоже самое что вызов по ключу через квадратные скобки, но если не будет значения вернёт None
# print(d1.get('ключ', 'своё значение')) # Можно изменить None на своё значение

# Возвращает значение выбранного ключа, если такого ключа нету создаёт ключ со значением None и так же возвращает None.
# Если указать через запятую своё значение то оно запишеться вместо None и оно же вернётся
# print(d1.setdefault("имя ключа", "имя значения"))
# print(d1)

# print(d1.pop(3)) # удаляет пару ключ:значение и возвращает значение удалённой пары, является аналогом del словарь[ключ]
# print(d1.popitem()) # удаляет случайную пару и возвращает ключ:значение удалённой пары

# print(d1.items()) # возвращает список с кортежами ключ:значение (нужен для работы с циклом for)
# print(d1.keys()) # возвращает ключи в виде списка (нужен для работы с циклом for) может использоваться как множество, т.к. ключи уникальны
# print(d1.values()) # возващает значения в виде списка (нужен для работы с циклом for)

# new_d = {2:'перезаписали значение двойки', 'профессия':'программист'}
# print(d1)
# d1.update(new_d) # добавить пары ключ:значение из одного словаря в другой, если ключи уже существуют их значения будут перезаписаны
# print(d1)

# a = d1.copy() # создаёт копию словаря в новой переменной
# print(len(d1)) # узнать количество пар в словаре
# print(2 in d1) # узнать есть ли такой ключ в словаре

# print(sorted(d1, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)

################################### ПРИМЕРЫ для Словаря ###################################

# class_room = {'Ivan':17, 'Nikolay':18, 'Klara':16}
# пробегаемся циклом по словарю без методов, получаем только ключи
# for key in class_room:
#     print(key)

# пробегаемся циклом по словарю методом keys(), получаем только ключи
# for key in class_room.keys():
#     print(key)

# пробегаемся циклом по словарю методом values() получаем только значения
# for value in class_room.values():
#     print(value)

# пробегаемся циклом по словарю методом items() получаем ключи и значения
# for key, value in class_room.items():
#     print(key, value)

# проверка есть ли определенный ключ в словаре
# if 'Klara' in class_room:
#     print('Данный ключ уже используеться!')
# else:
#     print('Вы можете использовать данный ключ для создания пары.')


# person = {}
# s = 'IVANOV IVAN Samara SGU 5 4 5 5 4 3 5'
# s = s.split()
# person['lastName'] = s[0]
# person['firstName'] = s[1]
# person['city'] = s[2]
# person['university'] = s[3]
# person['marks'] = []
# for i in s[4:]:
#     person['marks'].append(int(i))
# print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'city': 'Samara', 'university': 'SGU', 'marks': [5, 4, 5, 5, 4, 3, 5]}


# users = {
#     'Alex7': {'password':9856214, 'id':1957},
#     'Jimmy': {'password':1236487, 'id':9654},
#     'Bob33': {'password':9546752, 'id':6453}
# }
# # получить значение конкретного ключа в словаре можно с помощью квадратных скобок и имени ключа:
# print(users['Jimmy']['password'])
# print(users['Bob33']['id'])
# print(users['Alex7'])
# # либо же сразу всех элементов с помощью цикла
# for user_name, user_info in users.items():
#     password = user_info['password']
#     user_id = user_info['id']
#     print(f'Имя пользователя: {user_name} Пароль пользователя: {password} Айди пользователя: {user_id}')


# подсчёт уникальных символов в строке
# s = 'ssss dd  aaa'
# d = {}
# for i in s:
#     if i in d:
#         d[i] += 1
#     else:
#         d[i] = 1
# print(d)


# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# new = {}
# for i in price:
#     # копируем скидку 15% в новый словарь
#     new[i] = round(price[i] * 0.85, 2)
# print(price,"\n")
# print(new)


# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# new = {}
# for key, value in price.items():
#     new[value] = key # инверсия пары ключ значение
# print(price,"\n")
# print(new) # теперь ключём является стоимость товара а значением название


# price = {'meat':3, 'bread':1, 'potato':0.5, 'water':0.2}
# def buy():
#     pay = 0
#     print("\nЧто будете покупать?\n\nВыберите товар из списка ниже:\n\nmeat 3$, bread 1$, potato 0.5$, water 0.2$\n")
#     print("Как определитесь с выбором напишите end\n")
#     while True:
#         enter = input()
#         if enter == "end":
#             print("С вас: " + str(pay) + "$")
#             break
#         if enter in price:
#             pay += price[enter] # получаем значение из словаря price по ключу который введёт пользователь
#         else:
#             print('\nВыберите товар из списка ниже:\n\nmeat 3$, bread 1$, potato 0.5$, water 0.2$\n')
#     return str(pay) + "$"
# buy()

################################### Блок Словаря закончен ###################################

# flag = True
# x = int(input("Введите число: "))
# for i in range(1):
#     # если строка длинная то с помощью скобок её можно перенести
#     flag = ( flag and
#     x % 10 == 0 )
# print(flag)

# flag = False
# x = int(input("Введите число: "))
# for i in range(1):
#     flag = ( x % 10 == 0 ) or flag
# print(flag)

# Вложенные и последовательные if
# две записи снизу идентичны
# x = 6
# if x % 2 == 0:
#     if x % 3 == 0:
#         print('делиться на 6')

# if x % 2 == 0 and x % 3 == 0:
#     print('делиться на 6')

# каскадные конструкции
#  A    B    C    D
# --->|--->|--->|--->
#     0    5   10
# x = int(input("Введите число: "))
# if x < 0:
#     print("A")
# elif x < 5: # x >= 0
#     print("B")
# elif x < 10: # x >= 5
#     print("C")
# else: # x >= 10
#     print("D")

#     ^ y
#  2  |  1
# ----|---- > x
#  3  |  4
# y, x = 0, 0
# if y > 0:
#     if x > 0:
#         print(1)
#     else:
#         print(2)
# else:
#     if x < 0:
#         print(3)
#     else:
#         print(4)

####################
# Работа с файлами #
####################

# Контекстный менеджер with автоматически закрывает файл после работы с ним
# with open('C:\\pyTraining\\Тест папка\\Новый текстовый документ 4.txt', 'r') as file:
#     text = file.read()
#     print(text)

# записываем все пути из 'C:\\pyTraining\\Тест папка' в текстовый документ
# import os
# list_path = []
# for adress, folder, file, in os.walk('C:\\pyTraining\\Тест папка'):
#     for i in file:
#         full_path = os.path.join(adress, i)
#         list_path.append(full_path)
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt', 'w')
# for i in list_path:
#     file.write(i + '\n')
# file.close()

# находим определенный файл
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt')
# for i in file:
#     if 'testfile.exe' in i:
#         print(i)

# text = file.read() # прочитать весь файл целиком
# text = file.readline() # прочитать файл построчно
# text = file.readlines() # прочитать файл построчно и передать данные в переменную в виде списка
# text = file.write('строка текста') # записать в файл строку текста
# print(text)
# file.close() # закрыть файл

# 'r' Открыть для чтения (по умолчанию если не указывать параметр)
# 'w' Открыть для записи, содержимое файла удаляется, если файла нет, создаётся новый
# 'x' Открытие на запись, если файла не существует, иначе исключение.
# 'a' Открыть для дозаписи в конец файла, если файла нет, создаётся новый
# 't' Открыть в текстовом режиме (по умолчанию если не указывать параметр)
# 'b' Открыть в бинарном режиме (двоичном) 'rb', 'wb', 'ab'
# '+' Открыть для чтения и записи 'r+', 'w+', 'a+'

# запись текста в файл
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt', 'w')
# print(file)
# # file.write('текста строка')
# file.close()

# чтение текста из файла
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt')
# text = file.read()
# # text = file.read(5) # если указать число в функции read() можно прочитать определенное количество символов
# # text = file.seek(0) # указав число в функции seek() мы переместимся на чтение с указанного номера символа
# print(text)
# file.close()


# взаимодействие с бинарными файлами
# file = open('C:\\pyTraining\\Тест папка\\testfile.exe', 'rb')
# copy_file = open('C:\\pyTraining\\Тест папка\\Копия testfile.exe', 'wb')

# while True:
#     #                 1024 байт
#     value = file.read(1024*1024) # позволяет устанавливать сколько в ОЗУ во время копирования будет занимать место операция
#     print(value.__sizeof__()) # метод __sizeof__() позволяет узнать какой объем в ОЗУ занимает объект
#     if value.__sizeof__() == 33: # 33 не константа, может быть и другое число
#         break
#     copy_file.write(value)
# file.close()
# copy_file.close()


# # запись файла с определенной кодировкой
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 2.txt', 'w', encoding='utf-8')
# file.write('string текста')
# file.close()
# # если файл записан с необычной кодировской можно указать её для корректного чтения
# file2 = open('C:\\pyTraining\Тест папка\Новый текстовый документ 2.txt', encoding='utf-8')
# print(file2.read())

#######################################################################################################
# Множество (set) неупорядоченная коллекция уникальных элементов (отсутствуют повторяющиеся значения) #
# может состоять только из неизменяемых типов данных: число, строка, кортеж                           #
#######################################################################################################

# создать можно с помощью фигурных скобок
# a = {} # пустые фигурные скобки работают как словарь (dict), если перечислить данные через запятую получится множество
# так же создать множество можно с помощью функции set()
# y = set()
# print({"a", "a", "f", 1, 1, 1, 2, 3, 5, 25, (2, 5), (2, 5)}) # множество автоматически убирает повторяющиеся значения
# преобразуем список с повторяющимися значениями в множество затем обратно в список, тем самым убирая повторяющиеся значения
# print(list(set([1, 1, 2, 2, 3, 3, 4, 4, 5, 5])))

# x_tuple = (1, 2, 3, 4, 5, 6, 7)
# x_list = [1, 2, 3, 4, 5, 6, 7]
# x_dict = {'1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7}
# x_set = {1, 2, 3, 4, 5, 6, 7} # множества работают гораздо быстрее чем остальные типы списков
# # размер списка в памяти
# print(x_tuple.__sizeof__()) # 80
# print(x_list.__sizeof__()) # 96
# print(x_dict.__sizeof__()) # 344
# print(x_set.__sizeof__(), '\n') # 712
# from sys import getsizeof
# print(getsizeof(x_tuple)) # 80
# print(getsizeof(x_list)) # 96
# print(getsizeof(x_dict)) # 344
# print(getsizeof(x_set)) # 712

# Сравнение в скорости работы списка со множеством
# import time
# def f(*args):
#     list_new = []
#     for i in args:
#         for y in i:
#             if y not in list_new:
#                 list_new.append(y)
#     return list_new

# z = list(range(10000))
# x = list(range(5000, 15000))
# c = list(range(10000, 20000))

# start = time.time()
# f(z, x, c)
# stop = time.time() - start
# print('Время работы со списком:', stop)

# start2 = time.time()
# r = set(z)
# t = r.union(set(x), set(c))
# stop2 = time.time() - start2
# print('Время работы с множеством:', stop2)

# так же существует такой тип данных как frozenset, это множество элементы которого нельзя изменять
# print(frozenset([1, 1, "a"]), type(  frozenset([1, 1, "a"])  ))

# с множеством можно работать только при помощи методов

##########################################
# Методы для работы со множествами (set) #
##########################################

# z = {1, 2, 3, 4, 5}
# x = {3, 4, 5, 6, 7}

# при добавлении или объединении значения которые повторяются не будут дублироваться
# z.add(6) # добавить один элемент в множество
# z.update([7, 8]) # добавить значения из итерабильного объекта в множество
# z.update((9, 10))
# z.update({11, 12})
# z.update('ABCD')
# y = z.union(x) # объединить множества # аналог y = z | x
# z = z.union(x) # перезаписать объединённые множества в z # аналог z |= x
# z.discard(4) # удалить один элемент из множества (ничего не делает если такого элемента нет)
# z.remove(6) # удалить один элемент из множества (дропает исключение KeyError если такого элемента нет)
# z.pop() # удалить первый элемент из множества,
# но т.к. в множестве элементы не имеют постоянной позиции, по сути удаляет случайный элемент
# z.clear() # удалить все элементы из множества
# y = z.copy() # копия множества
# y = z.intersection(x) # получить повторяющиеся элементы в двух множествах # аналог y = z & x
# z.intersection_update(x) # перезаписать в z пересечение значений # аналог z &= x
# y = z.difference(x) # получить не повторяющиеся элементы из первого множества
# z.difference_update(x) # перезаписать в z не повторяющиеся элементы из первого множества # аналог ^=
# print(z ^ x) # получить не повторяющиеся элементы из первого и второго множества одновременно
# print(len(z)) # узнать количество элементов в множестве
# print(4 in z) # узнать есть ли конкретное значение в множестве
# print(z - x) # вычесть значения одного множества из значений другого множества
# print(z == x) # можно сравнивать множества
# print(z > x)
# print(z)
# print(y)
# z.issubset(x) # или  z <= x  все элементы z принадлежат x.
# z.issuperset(x) # или  z >= x  аналогично.
# z.isdisjoint(x) # истина, если z и x не имеют общих элементов.

# print(sorted(z, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)

###############################################################################################
# Строка (str) упорядоченная последовательность символов (присутствуют повторяющиеся символы) #
###############################################################################################

# поставив обратный слэш перед кавычками можно экранировать их
# тем самым вывести этот символ просто в качестве визуального элемента
# print("Я \"Арсений\" всем привет!")
# print('Я "Арсений" всем привет!')

# перенос строки на следующую строку (просто для оптимизации места на экране) (так же работает и для обычного кода)
# s = "qwerty\
# uiopa\
# sdfgh\
# jklzx\
# cvbnm"
# print(s)

# аналог переноса строки с помощью тройных кавчек (""", ''', ```)
# s = """qwerty
# uiopa
# sdfgh
# jklzx
# cvbnm"""
# print(s)

# строки могут сами конкатенироватся даже без '+'
# a = 'первый ' 'второй '   'третий'
# print(a)
# b = ('четвёртый '
#      'пятый '
#      'шестой')
# print(b)

# \n позволяет переносить строку на следующую по настоящему

# экранирование переноса строки изза \n с помощью второго слэша
# x = "https:\www.youtube.com\nexttab"
# x = "https:\www.youtube.com\\nexttab"

# специальный символ r перед строкой запрещает применять управляющие символы в данной строке
# x = r"https:\www.youtube.com\nexttab"
# для работы с путями в виндовс можно использовать r либо везде ставить двойной слэш
# x = 'C:\\Users\\PyHS\\Desktop'
# print(x)

# print('\f \v') # гендерные символы

# print('123\r456') # \r возврат в начало текущей строки
# print('123\b\b456') # \b возврат на один символ назад в текущей строке

# экранирование слэш что бы он не экранировал кавычку
# ('D:\')
# ('D:\\')

# сложение строк(конкатенация)
# a = "Привет " + "Мир!"
# print(a)

# Сравнение строк
# print('abc' > 'r') # Получим False т.к. сравнение начинается с 1 символа а 'r' имеет больший порядковый номер чем 'a'
# print(ord('a'), ord('r'), ord('2'), ord('7')) # функция ord позволяет узнать номер символа в таблице ASCII
# print(chr(ord('a')), chr(ord('r'))) # функция chr наоборот переводит номер символа в сам символ
# print('abc' < 'abcd') # если символы в строках одинаковые но одна строка длиннее другой то True будет на стороне более длинной строки

# s = "stroka texta"
# print(s[5]) # получаем конкретный символ по индексу
# print(s[2:6]) # срез строки со 2 по 6 символ
# print(s[3:]) # срез с левой стороны
# print(s[:9]) # срез с правой стороны
# print(s[::2]) # срез символов через символ
# print(s[::-1]) # инвертируем строку с помощью среза

# инвертируем строку обращаясь по индексу
# text = 'Кошка'
# print(text[4]+text[3]+text[2]+text[1]+text[0])

# инвертируем строку любой длинны с помощью цикла
# cat = 'Кошка'
# tac_table = []
# count = 0

# for letter in range(0, len(cat)):
#     count -= 1
#     tac_table.append(cat[count])

# inverseCat = ''.join(tac_table)
# print(inverseCat)

# инвертируем строку с помощью метода списков reverse()
# cat = 'Кошка'
# # превращаем строку в список с помощью генератора списка
# cat_table = [x for x in cat]
# cat_table.reverse() # применяем метод
# # превращаем инвертированный список обратно в строку
# inverseCat = ''.join(cat_table)
# print(inverseCat)

# возвращает True/False в зависимости от того есть ли такой текст в таком порядке символов в проверяемой строке или нет
# print('stra' in s)

#######################################
# Методы для работы со строками (str) #
#######################################

# s = 'Привет мир! Как дела народ?'
# уточнение для методов (find, rindex, count) индексация всегда идёт слева на право
# если указанного символа нет в тексте (find вернёт -1)(index вернёт ValueError)(count вернёт 0)
# (find, index, count) могут принимать доп арг. start, stop с какого и до какого индекса
# print(s.find('д')) # возвращает индекс первого попавшегося искомого символа либо строки из нескольких символов # метод rfind() ищет первый попавшийся символ справа на лево
# print(s.rindex('д')) # идентично с find просто может сыпать разные эрроры # rindex()
# print(s.count('д')) # узнать количество определенных символов
# print(len(s)) # узнать количество всех символов в строке
# print(s.upper()) # переводит все символы в верхний регистр
# print(s.lower()) # переводит все символы в нижний регистр
# print('a'.isupper(), 'A'.islower()) # проверит принадлежит ли символ к проверяемому регистру, вернёт булевое значение
# print('a'.swapcase(), 'A'.swapcase()) # меняет регистр на противоположный (переводит символы верхнего регистра в нижний регистр, а символы нижнего регистра в верхний регистр)
# print(s.capitalize()) # переводит первую букву в строке в верхний регистр а все остальные в нижний регистр
# print(s.title()) # переводит первую букву во всех словах в строке в верхний регистр
# print(s.istitle()) # если в строке большая буква только первая возвращает True иначе False
# print(s.strip()) # по дефолту удаляет неограниченное количество пробелов и преносов строк в начале и конце строки
# если указать символ он сделает тоже самое только с ним. Ещё методы которые убирают только с левой либо с правой стороны (lstrip, rstrip)
# print(s.isalpha()) # если символы являются только буквами возвращает True, иначе False
# print(s.isdigit()) # если символы являются только числами возвращает True, иначе False
# print(s.isalnum()) # если строка состоит из букв либо цифр или из букв вместе цифрами возвращает True иначе False
# print(s.replace('е', ' ^_^', 1)) # заменяет выбранный символ на другой, может принимать 3 арг. сколько замен надо произвести
# print(s.split('а')) # разделяет строку на сектора по выбранному символу и возвращает их в виде списка (по умолчанию по пробелам)
# print('111'.rjust(7, '$')) # вставляет символ заполнитель слева от строки # ljust аналогично только справа (по умолчанию заполн. пробел)
# print('abcd'.startswith('ab'), 'abcd'.startswith('ba')) # сравнивает указанный префикс с началом строки возвращает True если префикс совпадает
# print('abcd'.endswith('cd'), 'abcd'.endswith('dc')) # сравнивает указанный префикс с концом строки возвращает True если префикс совпадает

# print(reversed('98765')) # создаёт итератор с инвертированными элементами
# print(''.join(list(reversed('98765')))) # пример

# print(repr('строка вместе с одинарными кавычками\n\n')) # возвращает строку вместе с кавычками и управляющими знаками

# функцию max и min можно использовать и для вычисления самой длинной строки передав в аргумент key функцию len
# print(max('aa', 'aaa', key=len))
# print(min('aa', 'aaa', key=len))
# либо даже так, возвращаем ключ максимального значения из словаря:
# from collections import Counter
# print(max(Counter([2,2,1,1,1,2,2]).items(), key=lambda tuple: tuple[1])[0])

# так же max можно использовать для сравнения строк, функция будет взвращать <class 'str'>
# сравнение происходит по номеру каждого символа слево на право по таблице ASCII
# print(max(['111', '444', '333']), type(max(['111', '444', '333'])))
# print(ord('1'), ord('4'), ord('3'))

# print(sorted(s)) # возвращает новый отсортированный список в переменную (родительский не трогает)
# print(sorted(s, key=str.lower)) # может принимать в качестве key методы сортируемого объекта в данном случае строки

# a = ['ZZZ 800', 'aaa 45', 'eee 43', 'DDD 800', 'BBB 43', 'www 14']
# # сортировка чисел в строке по возврастанию, сортировка букв по алфавиту без учёта регистра
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower())))
# # тоже самое только сортировка чисел по убыванию с помощью -int
# print(sorted(a, key=lambda x: (-int(x.split()[1]), x.split()[0].lower())))
# # тоже самое только сортировка как чисел так и букв по убыванию с помощью аргумента reverse
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower()), reverse=True))

# исключение(фильтрация) элементов последовательности по условию в переданной функции
# print(list(filter(lambda x: x > 4, [1, 2, 3, 4, 5, 6, 7])))


# reduce() применяет функцию к элементам последовательности, сводя ее к единственному значению
# from functools import reduce
# data = {"a": { "b": { "c": { "mykey": "myvalue"}}}}
# print(reduce(dict.get, ["a", "b", "c", "mykey"], data))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4]))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4], 7)) # третий арг. добавится к итоговому результату


# класс map принимает итерируемую последовательность вторым аргументом и функцию первым
# через которую будет прогонятся каждый элемент этой последовательности
# на выходе мы получим итератор с результатом выполнения по которому можно пройтись циклом либо просто обернуть в класс list()
# x = [0, 1, -10, 5, -8, 3]
# print(list(map(abs, x)))

# класс map совместно с методом split позволяет принимать аргументы от функции input
# написанные через пробел и преобразовывать их в другой тип
# n1, n2, n3 = map(int, input('Введите три числа через пробел: ').split()) # 1 2 3
# print('числа:', n1, n2, n3)
# n4, n5, n6 = map(str, input('Введите три буквы через пробел: ').split()) # a b c
# print('буквы:', n4, n5, n6)

# вместо int/str можно предать свою функцию или методы
# n00, n01, n02 = map(str.upper, ['hello', 'hi', 'good morning'])
# print(n00, n01, n02)

# аналогичный код функции map()
# n7, n8, n9 = [int(x) for x in input('Введите три числа через пробел: ').split()]
# print('числа:', n7, n8, n9)
# n10, n11, n12 = [str(x) for x in input('Введите три буквы через пробел: ').split()]
# print('буквы:', n10, n11, n12)


# метод строк translate позволяет заменить некоторые знаки или удалить их
# в методе str.maketrans 1 и 2 арг. отвечает за то какой знак на какой заменять, 3 арг что удалить из строки
# с помощью метода punctuation из модуля string получаем строку со знаками пунктуации
# from string import punctuation
# print(s.translate(str.maketrans('', '', punctuation)))
# print(punctuation)


# английский алфавит и цифры
# import string
# letters = string.ascii_letters
# digits = string.digits
# print(letters, digits)


# алгоритм генерации русского алфавита
# letters = ''.join([chr(c) for c in range(ord('а'), ord('а')+6)] + [chr(ord('а')+33)] + [chr(c) for c in range(ord('а')+6, ord('а')+32)])
# print(letters)


# # добавление текста в строку при помощи кортежа и спец символа %s
# d = "Hello %s I am %s and im %s good" % ('Arseniy', 'Python', 'Чертовски')
# print(d)

# a = "Какой то текст %(count)d %(items)s" % {"count": 19, "items": {"my_key1": "my_value1", "my_key2": "my_value2"}}
# print(a)
# b = "Какой то текст %(my_key)s" % {"my_key": "my_value"}
# print(b)
# c = "Какой то текст %s" % "ещё текст"
# print(c)
# d = "Какое то число %d" % 174
# print(d)

# # добавление текста в строку с помощью метода format() и спец символа {}
# # в данном примере строки в методе format представляют из себя кортеж
# # обращаясь по индексам к данному кортежу можно подставлять текст в любое место строки
# a = "Hello {0} I am {1} and im {2} good".format('Arseniy', 'Python', 'Чертовски')
# print(a)
# # в данном примере строки в методе format мы передали в качестве аргументов
# # соответственно в строку и нужно подставлять ключи этих аргументов
# x = "Hello {name} I am {lang} and im {phrase} good".format(name='Arseniy', lang='Python', phrase='Чертовски')
# print(x)


# третий вариант самый лучший с помощью спец символа f перед строкой и фигурных скобок в которых можно записывать всё что угодно
# name = 'Arseniy'
# print(f'Hello {name} I can do it in f-string {5*5}')
# print(f'{name=}') # с помощью знака = после переменной, получаем имя=значение


# print(f'{3.8 :.2f}') # Количество знаков после точки для дробного числа
# print(f'{1030.2 :,.2f}') # Разделитель для целого числа и количество знаков после точки для дробного числа
# print(f'{1120 :,d}') # Вывести целое число, если число больше 999 то ставится запятая в качестве разделителя
# print(f'{3.8 :.1%}') # Умножает значение на 100, позволяет задать количество знаков после точки и добавляет знак процента в конце
# print(f'{200 :b}') # Представление числа в двоичном коде
# s = 'abcdef'
# print(f'{s :.3s}') # Макс количество символов отображаемых в строке, обрезание происходит справа на лево

# a = ((1024*1024)*42) / 1024
# print(a)
# aa = f'{a :,.0f}'[:-1]
# print(aa)

################################### Блок Строки закончен ###################################

# raise ValueError('текст') # оператор вызова исключения с кастомным текстом

# Обработка ошибок в пайтон

# while True:
#     # пробуем исполнить код, если нет ошибок то он исполняется здесь
#     try:
#         enter = float(input("Введите число: "))
#         print("\nИсполнение try")
#     # если тип ошибки ValueError выполняем такой код
#     # можно не прописывать определенную ошибку тогда except: исполниться при любой ошибке
#     except ValueError:
#         print("\nexcept ValueError")
#     # если тип ошибки ZeroDivisionError то выполняем другой код
#     except ZeroDivisionError:
#         print("\nexcept ZeroDivisionError")
#     # обработка нескольких исключений в одном блоке except
#     except (ValueError, ZeroDivisionError):
#         print("\nexcept ValueError, ZeroDivisionError")
#     # не обязательный оператор else он исполниться только если успешно выполнен блок try и не задействован блок except
#     else:
#         print("Исполнение else")
#     # не обязательный оператор finally он исполниться и при try и при except
#     finally:
#         print("Исполнение finally")

# Обрабатывая одно исключение, обрабатываются все исключения ниже по иерархии
# например обрабатывая исключение LookupError обрабатываются IndexError, KeyError

# поиск необходимого исключения в блоке except идёт сверху вниз,
# кто первый найдётся будь он даже родительским исключением и будет использован для обработки.
# try:
#     2 + '2'
# except ValueError:
#     print('except ValueError:')
# except TypeError:
#     print('except TypeError:')
# except Exception:
#     print('except Exception:')

# try:
#     2 + '2'
# except Exception:
#     print('except Exception:')
# except TypeError:
#     print('except TypeError:')

# # так же можно записывать сразу несколько видов исключений в одну конструкцию except в виде кортежа.
# try:
#     2 + '2'
# except (ValueError, TypeError):
#     print('except (ValueError, TypeError):')

# try:
#     try:
#         raise ValueError('сообщение об исключении')
#     except Exception as exc:
#         print("INNER try-except", exc)
#         # для того чтобы внешний блок узнал о исключении во внутреннем
#         # можно рерайзнуть исключение и оно попадёт во внешний блок
#         raise
# except Exception as exc:
#     print("OUTER try-except", exc)

# Иерархия встроенных классов исключений

# BaseException - базовое исключение, от которого берут начало все остальные.
#     SystemExit - исключение, порождаемое функцией sys.exit при выходе из программы.
#     KeyboardInterrupt - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
#     GeneratorExit - порождается при вызове метода close объекта generator.
#     Exception - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
#         StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов.
#         ArithmeticError - арифметическая ошибка.
#             FloatingPointError - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
#             OverflowError - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
#             ZeroDivisionError - деление на ноль.
#         AssertionError - выражение в функции assert ложно.
#         AttributeError - объект не имеет данного атрибута (значения или метода).
#         BufferError - операция, связанная с буфером, не может быть выполнена.
#         EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
#         ImportError - не удалось импортирование модуля или его атрибута.
#         LookupError - некорректный индекс или ключ.
#             IndexError - индекс не входит в диапазон элементов.
#             KeyError - несуществующий ключ (в словаре, множестве или другом объекте).
#         MemoryError - недостаточно памяти.
#         NameError - не найдено переменной с таким именем.
#             UnboundLocalError - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
#         OSError - ошибка, связанная с системой.
#             BlockingIOError
#             ChildProcessError - неудача при операции с дочерним процессом.
#             ConnectionError - базовый класс для исключений, связанных с подключениями.
#                 BrokenPipeError
#                 ConnectionAbortedError
#                 ConnectionRefusedError
#                 ConnectionResetError
#             FileExistsError - попытка создания файла или директории, которая уже существует.
#             FileNotFoundError - файл или директория не существует.
#             InterruptedError - системный вызов прерван входящим сигналом.
#             IsADirectoryError - ожидался файл, но это директория.
#             NotADirectoryError - ожидалась директория, но это файл.
#             PermissionError - не хватает прав доступа.
#             ProcessLookupError - указанного процесса не существует.
#             TimeoutError - закончилось время ожидания.
#         ReferenceError - попытка доступа к атрибуту со слабой ссылкой.
#         RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий.
#         NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
#         SyntaxError - синтаксическая ошибка.
#             IndentationError - неправильные отступы.
#                 TabError - смешивание в отступах табуляции и пробелов.
#         SystemError - внутренняя ошибка.
#         TypeError - операция применена к объекту несоответствующего типа.
#         ValueError - функция получает аргумент правильного типа, но некорректного значения.
#         UnicodeError - ошибка, связанная с кодированием / раскодированием unicode в строках.
#             UnicodeEncodeError - исключение, связанное с кодированием unicode.
#             UnicodeDecodeError - исключение, связанное с декодированием unicode.
#             UnicodeTranslateError - исключение, связанное с переводом unicode.
#         Warning - предупреждение.


# import sys
# url_list = [
#     'Тест папка\\Новая папка (3)\\Новый текстовый документ 1.txt',
#     'Тест папка\\Новая папка (3)\\Новый текстовый документ 2.txt',
#     'Тест папка\\Новая папка (3)\\Новый текстовый документ 3.txt', # типо битый файл
#     'Тест папка\\Новая папка (3)\\Новый текстовый документ 4.txt'
# ]
# list_info = []
# list_defect = []

# try:
#     for url in url_list:
#         try:
#             r = open(url, encoding='utf-8')
#             list_info.append(r.read())
#             print('try')
#         except Exception:
#             list_defect.append(url)
#             print('except')
#             sys.exit() # имитируем выход из программы перед чтением последнего элемента в списке
#             continue
# finally:
#     r = open('Тест папка\\Новая папка (3)\\save.txt', 'a')
#     for i in list_info:
#         r.write(i)
#     r.write(str(list_defect))
#     r.close()
#     print("Я всё записал не смотря ни на что!")

# ниже указано 2 по сути аналогичных метода автоматического сохранения содержимого файла при ошибке
# оба метода запишут данные только до строки с ошибкой
# try:
#     r = open('Тест папка\\Новая папка (4)\\Новый текстовый документ 1.txt', 'a')
#     r.write('something' + '\n')
#     10/0 # нарошно допускаем ошибку
#     r.write('записываем ещё что-то')
# finally:
#     r.close()
#     print('запись завершена')

# with open('Тест папка\\Новая папка (4)\\Новый текстовый документ 1.txt', 'a') as r:
#     r.write('something' + '\n')
#     10/0 # нарошно допускаем ошибку
#     r.write('записываем ещё что-то')
# print("запись завершена")

#################### PYINSTALLER # pip install pyinstaller ####################

# pyinstaller --version

# Если использовать параметр -D тогда .exe и все файлы будут помещены в одну общую папку и открытие будет происходить в командной строке
# для корректной работы необходимо перекинуть все исходные файлы программы в созданную папку

# Если использовать параметр -w тогда .exe и все файлы будут помещены в одну общую папку и открытие будет происходить без командной строки
# для корректной работы необходимо перекинуть все исходные файлы программы в созданную папку

# Если использовать параметр -F тогда будет создан один .exe файл и открытие будет происходить в командной строке
# для корректной работы необходимо перекинуть .exe к исходным файлам программы

# Можно задать имя отличное от компилируемого файла написанное слитно параметром -n новое_имя

# ( первый способ ) можно в ручную добавлять или убирать запуск консоли --windowed с консолью --noconsole без консоли
# ( второй способ ) для запуска без консоли необходимо поменять расширение файла с .py на .pyw

# можно задать кастомную иконку для .exe файла параметром --icon=имяиконки.ico

# преобразуем картинки в .ico файл # https://www.icoconverter.com/

# команда на живом примере: # pyinstaller -F --noconsole --icon=gear80x80.ico -n BackUpFolders BUFcore.py

#################### Команды терминала ####################

# проверяем версию пайтон # python -V
# проверяем версию пип # pip -V
# обновить пип # python -m pip install --upgrade pip

# установка новых либ # pip install имяЛибы
# установка определенной версии либы # pip intall имяЛибы==номерВерсии
# обновление установленных либ # pip install -U pip имяЛибы
# обновление установщика pip # c:\python3-8-9\python.exe -m pip install -U pip pip

# удаление установленных либ # pip uninstall имяЛибы -y
# удаление всех либ прописанных в файле requirements.txt с помощью команды # pip uninstall -r requirements.txt -y
# или # pip uninstall -r requirements.txt
# проверяем установленные либы в глобальном окружении # pip list

# Если pip выдаёт ошибку: Fatal error in launcher: Unable to create process using
# выполняем 3 команды по очереди (возможно поможет):
# python -m pip uninstall pip
# python -m ensurepip
# python -m pip install -U "pip<10"

# Если pip выдаёт ошибку: Fatal error in launcher: Unable to create process using
# возможно поможет удаление и создание нового виртуального окружения, если оно конечно используется

# проверяем установленные либы в виртуальном окружении # pip freeze
# если дропает ошибку: 'Fatal error in launcher: Unable to create process using' тогда: python -m pip freeze

# создаём текстовый файл с используемыми либами в проекте с виртуальным окружением # pip freeze > requirements.txt
# если дропает ошибку: 'Fatal error in launcher: Unable to create process using' тогда: python -m pip freeze > requirements.txt

# создаём текстовый файл с используемыми либами в глобальном окружении # pip list > C:/pyTraining/requirements.txt

# создаём виртуальное окружение # python -m venv venv
# виртуальное окружение необходимо для того что бы загружать в него либы необходимые для работы скрипта

# активация виртуального окружения # venv/Scripts/activate.bat
# деактивация виртуального окружения # venv/Scripts/deactivate.bat
# либо сочетание клавиш в vsCode # ctrl+shift+P # затем Python: Выбор интерпритатора

# установка либ с помощь файла зависимостей # pip install -r requirements.txt

#############
# Замыкания #
#############

# Замыкание функции это когда в неё передаётся значение и запоминается в ней для последующего вызова, затем возвращается функция обёртка
# def adder(first_value):

#     def inner(second_value):
#         return first_value + second_value

#     return inner

# # сначала вызываем функцию 'def adder' она запоминает значение аргумента 'first_value'
# # далее возвращаем функцию 'def inner' которая помещается в переменную 'f1' для последующего вызова
# f1 = adder(2)
# # затем вызываем функцию 'def inner' содержащуюся в переменной 'f1' и передаём в неё значение 'second_value'
# # далее 'first_value' складывается с 'second_value' и возвращается на распечатку
# print(f1(4))

##############
# Декораторы #
##############

# from functools import wraps

# # декоратор это функция которая позволяет обернуть другую функцию в свой код при этом не трогая оригинальный код
# def decorator(func_name):
#     # декоратор @wraps нужен для того что бы __name__ и __doc__ отображали информацию о родительской функции а не об обёртке
#     @wraps(func_name)
#     def wrapper():
#         """Документация тестовой функции wrapper"""
#         print('Выполнился код декоратора перед вызовом родительской функции make()') # выполняем код декоратора
#         print('Аргумент func_name ==', func_name) # переданный аргумент представляет собой имя функции
#         func_name() # выполненяем функцию make()
#         print('Выполнился код декоратора после вызова родительской функции make()') # продолжаем выполнение кода декоратора
#     return wrapper # возвращаем имя обёртки. make = wrapper()

# # как аргумент в функцию decorator передаётся имя функции make
# @decorator # make = decorator(make)
# def make():
#     """Документация тестовой функции make"""
#     print('Выполнился код внутри функции make()')
# print('Запускаем функцию make() под декоратором @decorator')
# make()
# print('Код выполнен.')

# print('\nИмя функции:', make.__name__)
# print('Документация функции:', make.__doc__)


# Можно записать декоратор с пробросом дополнительных аргументов, выглядеть это будет так,
# просто добавляется ещё один внешний декоратор с помощью которого и декорируется необходимая
# функция, аргументы передеанные в этот внешний декоратор при обёртывании и попадут в _args, _kwargs
# def outer_decor(*_args, **_kwargs):
#     def decorator(func):
#         def wrapper(*args, **kwargs):
#             print('аргументы переданные в outer_decor при обёртывании:', _args, _kwargs)
#             print('аргументы переданные в функцию function:', args, kwargs)
#             func(*args, **kwargs)
#         return wrapper
#     return decorator

# @outer_decor(1, 2, a=3, b=4)
# def function(text, num, key_word_key):
#     pass
# function('abc', 777, key_word_key='key_word_value')

# тот же самый декоратор но без синтаксического сахара:
# def function(text, num, key_word_key):
#     pass
# function_outer_decor = outer_decor(1, 2, a=3, b=4)(function)
# function_outer_decor('abc', 777, key_word_key='key_word_value')
# можно даже записать в одну строку:
# outer_decor(1, 2, a=3, b=4)(function)('abc', 777, key_word_key='key_word_value')


# Декоратор который кэширует результат вычислений функции func_name
# и в случае повторного запроса с такими же входными данными
# не будет заного считать а вернёт кэшированный результат.

# cache = {}

# def decor_func(func):

#     def wrapper(*args, **kwargs):

#         if args in cache:
#             #print(f'return cache | {args=}')
#             return cache[args]

#         result = func(*args)

#         cache[args] = result
#         # cache.update({args:result}) # способ добавления пары в словарь с помощью метода update

#         #print(f'create cache | {args=}')

#         return result

#     return wrapper


# @decor_func
# def func(x):
#     print("Wait im calculating")
#     return x*x + 1


# print('return:', func(4), '  cache:', cache)
# print('return:', func(4), '  cache:', cache)
# print('return:', func(4), '  cache:', cache)
# print('return:', func(6), '  cache:', cache)
# print('return:', func(6), '  cache:', cache)

################################################################
# Генераторы списков, словарей, множеств и Выражение генератор #
################################################################

# lst = [9, 8, 7, 4, 5, 6, 3, 2, 1, 5, 5]

# первый способ создания изменённого списка
# lst0 = []
# for x in lst:
#     lst0.append(x * 2)
# print('lst0:', lst0)

# второй способ создания изменённого списка с помощью генератора-списков (list comprehension) (работает быстрее обычного цикла)

# отличия от обычного цикла в том что сначало берём весь код в скобки
# (зависит от того в какой список мы хотим автоматически преобразовать последовательность)
# затем пишется действие которое будем производить с полученным значением в переменной
# затем for (переменная в которую присваивается значение при итерации) in (итерируемая последовательность)
# lst1 = [x * 2 for x in lst] # создание списка
# print('lst1:', lst1)

# # выражение-генератор (generator expression) можно проитерировать только один раз
# lst2 = (x * 2 for x in lst) # создание выражения генератора
# print('lst2:', lst2)
# # т.к. выражение-генератор является итератором из него можно получить элементы по очереди с помощью функции next()
# print('next1:', next(lst2))
# print('next2:', next(lst2))
# print('next3:', next(lst2))
# # либо же с помощью цикла
# for item in lst2:
#     print('item:', item)

# выражение-генератор (generator expression) позволяет экономить место в ОЗУ т.к.
# не создаётся огромный список как с генератором списка
# отличие при создании только в круглых скобках
# import os
# n = [x for x in os.walk('C:\\pyTraining')] # генератор списка
# print('генератор списка:', n.__sizeof__())
# z = (y for y in os.walk('C:\\pyTraining')) # выражение-генератор
# print('выражение генератор:', z.__sizeof__(), z)

# lst3 = {x * 2 for x in lst} # создание генератора-множества (set comprehension)
# print('lst3:', lst3)

# в словаре отличие лишь в том что сначало надо записать значение которое пойдёт в качестве ключа
# и поставить двоеточие, затем всё как и с другими типами списков
# lst4 = {x / 2: x * 2 for x in lst} # создание генератора-словаря (dict comprehension)
# print('lst4:', lst4)

# преобразование первых букв в заглавные и изменение строкового значение на инт
# d = {'джефф безос': '177', 'илон маск': '126', 'бернар арно': '150', 'билл гейтс': '124'}
# d2 = {k.title(): int(v) for k, v in d.items()}
# print(d)
# print(d2)

# lst = ['a', 1, 'b', 2, 'c', 3, 'd', 4, 'e', 5, 'f', 6]
# d = {lst[i]: lst[i+1] for i in range(0, len(lst)-1, 2)}
# print(d)

# Добавление условий в генератор
# условие записывается после записи (итерируемой последовательности) если нужен только 'if'
# lst5 = [x for x in [9, 8, 7, 4, 5, 6, 3, 2, 1, 5, 5] if x % 2 == 0]
# print('lst5:', lst5)

# условие записывается перед записью (итерируемой последовательности) если нужен как 'if' так и 'else'
# lst6 = [x if x % 2 == 0 else x ** x for x in [9, 8, 7, 4, 5, 6, 3, 2, 1, 5, 5]]
# print('lst6:', lst6)

# ещё пример со строкой
# lst6 = [x * 4 for x in 'a1b2c3d4e5' if x.isalpha()]
# print('lst6:', lst6)

# Если нужно условие if по результату которого мы уже переходим ко вложенным if else запись такая:
# четные числа range(0-9): [0, 2, 4, 6, 8]
# порядок выполнения условий: (во второе и третье условие попадают только четные числа которые прошли первое условие)
# #    |  второе | |  третье |                    |   первое  |
# x = [n if n == 8 else n * 20 for n in range(10) if n % 2 == 0]
# print(x) # [0, 40, 80, 120, 8]

# пример генераторов со вложенными циклами

# lst1 = [x * y for x in [2, 3, 4, 5] for y in [1, 2, 3] if y % 2 == 1]
# lst2 = []
# for x in [2, 3, 4, 5]:
#     for y in [1, 2, 3]:
#         if y % 2 == 1:
#             lst2.append(x * y)
# print(lst1, lst2)

# lst3 = [[x * y for x in [2, 3, 4, 5]] for y in [1, 2, 3] if y % 2 == 1]
# lst4 = []
# for y in [1, 2, 3]:
#     lst = []

#     for x in [2, 3, 4, 5]:
#         lst.append(x * y)

#     if y % 2 == 1:
#         lst4.append(lst)
# print(lst3, lst4)


# парсер .txt файлов на компьютере
# import os
# all_files = [os.path.join(folders_path, files) for folders_path, list_folders, list_files in os.walk('C:\\pyTraining\\Тест папка')
#                                                for files in list_files if '.txt' in files]
# print(all_files)
# print('Количество файлов:', len(all_files))

# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# # 1 способ
# new_price = {}
# for key in price.keys():
#     new_price[key] = round(price[key] * 0.85, 2) # создаём новый список на основе старого с применением скидки 15%
# print(new_price)
# # 2 способ
# new_price2 = {key: round(price[key] * 0.85, 2) for key in price.keys()}
# print(new_price2)

# sites = ['https:\\www.сайт.com', 'https:\\www.какойтосайт.net',
#     'https:\\www.левыйсайт.com', 'https:\\www.другойсайт.com',
#     'https:\\www.сайтишка.net', 'https:\\www.сайтец.org']
# # индекс 0 = https:   индекс 1 = www.сайт.com
# com_sites = [site.split('\\')[1] for site in sites if '.com' in site]
# print(com_sites)


# обычная функция записывает все прочтённые данные в список list_text тем самым сильно засоряя ОЗУ
# def some():
#     list_text = []
#     with open('C:\\pyTraining\\Тест папка\\Новая папка (4)\\text.txt', encoding='utf-8') as file:
#         for text in file:
#             list_text.append(text)
#     return list_text
# for text in some():
#     print(text.split())

# функция генератор выдаёт значения по очереди тем самым не засоряя ОЗУ
# если прописан оператор yield то пайтон создаёт из этой функции объект генератор
# если мы запустим эту функцию в цикле for который будет запрашивать по 1 значению за раз
# эта функция будет выдавать по 1 значению для каждого цикла for
# def some():
#     with open('C:\\pyTraining\\Тест папка\\Новая папка (4)\\text.txt', encoding='utf-8') as file:
#         for text in file:
#             yield text # замена оператора return
# <class 'generator'> <generator object some at 0x000001EFCE31ECF0> строка текста
# print(type(some()),                     some(),                     next(some()))
# for text in some():
#     print('for:', text.split())

# # можно запрашивать по одному значению из генератора с помощью функции next
# text = some()
# print('next:', next(text).split())
# print('next:', next(text).split())
# print('next:', next(text).split())


# def func():
#     yield 1
#     yield 2
#     yield 3
# f = func()
# print(next(f))
# print(next(f))
# print(next(f))
# # print(next(f)) # exception: StopIteration


# def first():
#     yield 1
#     yield 2

# def second():
#     # импорт генератора в генератор
#     yield from first()
#     yield 3
#     yield 4
# s = second()
# for i in s:
#     print(i)

##################
# lambda функции #
##################

# Структура lambda функции
# даём имя функции        принимаем аргументы : работаем с аргументами
# lambda_function_name = lambda arg1, arg2, arg3: arg1 + arg2 + arg3
# в lambda функции уже стоит невидимый return который вернёт результат работы функции
# вызываем функцию по имени переменной и передаём аргументы
# print(lambda_function_name(2, 2, 2))

# Структура lambda функции с условиями
# сначало записывается объект (в нашем случае это arg1) который вернётся в результате выполнения оператора if
# затем сам оператор if и условие для его выполнения
# затем оператор else и объект который вернётся в результате выполнения оператора else
# lambda_function_name = lambda arg1, arg2: arg1 if arg1 > arg2 else arg1 + arg2
# print('вызов с арг. (4, 6) =', lambda_function_name(4, 6), '\nвызов с арг. (6, 4) =', lambda_function_name(6, 4))

# Применение lambda функции в сравнении с обычной функцией
# имеем список который необходимо отсортировать по возврастанию последнего символа в числе
# первый пример с использованием lambda функции второй с использованием обычной функции, результат одинаков
# lst = [78, 56, 23, 8, 54512, 65, 95, 2354, 41, 5000]
# srt_lst1 = lst.sorted(key=lambda x: x % 10)
# print(srt_lst1)

# def sort_func(x):
#     return x % 10
# srt_lst2 = lst.sorted(key=sort_func)
# print(srt_lst2)

# фильтрация элементов списка по условию
# функцию filter можно использовать для создания нового списка
# на основе старого исключив какие то значения
# lst = [['Adam', 29], ['Jonny', 16], ['Jess', 24], ['Karl', 7], ['Antony', 32]]
# new_lst = list(filter(lambda age: age[1] >= 18, lst))
# print(new_lst)

# исключаем буквы с помощью метода isdigit в функции filter
# print(list(filter(str.isdigit, '432jfdsHFDS343f')))

# a = b = c = d = e = True
# # a = b = c = d = False or None
# # e = True
# all и any принимают на вход только коллекцию
# # Если все элементы True условие срабатывает
# if all((a, b, c, d, e)):
#     print('All', all((a, b, c, d, e)))
# # Если один из элементов True условие срабатывает
# if any((a, b, c, d, e)):
#     print('Any', any((a, b, c, d, e)))


# узнать версию OS
# from sys import platform
# print(platform)


# Узнать локализацию виндовс системы, возвращает: ru_RU или en_US
# import locale
# import ctypes
# windll = ctypes.windll.kernel32
# localization = locale.windows_locale[windll.GetUserDefaultUILanguage()]
# print(localization)

# print(' ') # символ пустышка, создаёт пробелы
# print('⚠️ ▶️ ❌ 🏁 👍 ✔ █ ✖')
# print('⮜ ⮞ ⮝ ⮟')

# Матрицы # https://silvertests.ru/GuideView.aspx?id=34372

# index 0 1 2 3
#     |---------
#   0 | 1 2 4 29
#   1 | 3 4 6 1

# arr = [
#     [1, 2, 4, 29],
#     [3, 4, 6, 1]
# ]

# Создание матрицы с тремя столбцами по два элемента каждый
# N = 3
# M = 2
# A = []
# for i in range(N):
#     A.append([0]*M)
# print(A)

# сделать то же самое можно с помощью генератора
# N = 3
# M = 2
# A = [ [0]*M for i in range(N) ]

# Заполнение матрицы
# for i in range(N):
#     for j in range(M):
#         A[i][j] = 6

# Вывод матрицы по индексам на экран для удобства восприятия
# for i in range(len(A)):        # возвращает количество строк в матрице
#     for j in range(len(A[i])): # возвращает количество элементов в строке
#         print(A[i][j], end=' ')
#     print()                    # делаем переход на новую строку

# Вывод матрицы по значениям списка на экран для удобства восприятия
# for row in A:               # делаем перебор всех строк матрицы
#     for elem in row:        # перебираем все элементы в строке
#         print(elem, end=' ')
#     print()                 # делаем переход на новую строку

# Вывод матрицы по значениям списка на экран для удобства восприятия
# for row in A:
#     print(' '.join(list(map(str, row))))

# встроенный модуль copy позволяет создавать копии: словарей, множеств, списков, пользовательских классов (мб что-то ещё)
# import copy
# test_1 = [1, 2, 3, [1, 2, 3]]
# test_copy = copy.copy(test_1)
# print(test_1, test_copy)
# # [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3]]

# test_copy[3].append(4)
# print(test_1, test_copy)
# # [1, 2, 3, [1, 2, 3, 4]] [1, 2, 3, [1, 2, 3, 4]]

# test_1 = [1, 2, 3, [1, 2, 3]]
# test_deepcopy = copy.deepcopy(test_1)
# test_deepcopy[3].append(4)
# print(test_1, test_deepcopy)
# # [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3, 4]]


# for num in range(39):
#     summ = 0
#     summ2 = 0

#     for n in str(num):
#         summ += int(n)

#     for n in str(summ):
#         summ2 += int(n)

#     if summ2 == 2:
#         print(num, summ2)


# Подмена строки по полу человека
# gender = {
#     'male':'Дорогой',
#     'female':'Дорогая'
# }

# data = [
#     ['Семён', 'Семёнович', 32.56, 'male'],
#     ['Тамара', 'Ивановна', 13.12, 'female'],
#     ['Михаил', 'Анатольевич', 238.12, 'male']
# ]

# for name, mid_name, balance, gen in data:
#     text = f'{gender[gen]} {name} {mid_name}, баланс вашего лицевого счёта составляет {balance} руб.'
#     print(text)


# Алгоритм Евклида для нахождения НОД (наибольшего общего делителя) двух целых чисел
# a = int(input('Введите большее число: '))
# b = int(input('Введите меньшее число: '))

# while b > 0:

#     c = a % b
#     a = b
#     b = c

# print(a)


# Нахождение всех делителей числа
# n = int(input())
# i = 1
# a = []
# while i * i <= n:
#     if n % i == 0:
#         a.append(i)
#         if i != n // i:
#             a.append(n // i)
#     i += 1
# a.sort()
# print(a)


# Треугольник Паскаля
# n = int(input('Введите число: '))
# triangle = []

# for i in range(n+1):
#     triangle.append([1]+[0] * n)

# for i in range(1, n+1):
#     for j in range(1, i+1):
#         triangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]

# for i in range(0, n+1):
#     for j in range(0, n+1): # i+1 # убрать нули по диагонали
#         if triangle[i][j] < 10:
#             print(triangle[i][j], end='  ')
#         else:
#             print(triangle[i][j], end=' ')
#     print()


# Рекурсия

# def recursion(x):
#     print(x)
#     if x == 1: return
#     return recursion(x - 1)
# print(recursion(5))

# def get_factorial(x):
#     print('x:', x)
#     if x == 1: return x
#     return x * get_factorial(x - 1)

# print(get_factorial(5))
# print(5*4*3*2)

# rnd_str = 'LItBeoFLcSGBOFQxMHoIuDDWcqcVgkcRoAeocXO'

# count = 0
# new_rnd_str = ''
# for char in rnd_str:
#     count += 1
#     if count <= len(rnd_str) / 2:
#         if len(rnd_str) % 2 == 0 and count == len(rnd_str) / 2:
#             new_rnd_str += char
#         else:
#             new_rnd_str += char + '('
#     elif count == len(rnd_str):
#         new_rnd_str += char
#     else:
#         new_rnd_str += char + ')'
# print(new_rnd_str)


# # count = 0
# # new_rnd_str = ''
# def rec_add_hooks(rnd_str, count=0, new_rnd_str=''): # вместо global переменных можно укзать параметры функции
#     # global count
#     # global new_rnd_str

#     if count + 1 <= len(rnd_str) / 2:

#         if len(rnd_str) % 2 == 0 and count + 1 == len(rnd_str) / 2:
#             new_rnd_str += rnd_str[count]
#         else:
#             new_rnd_str += rnd_str[count] + '('

#     elif count + 1 == len(rnd_str):
#         new_rnd_str += rnd_str[count]
#         return new_rnd_str

#     else:
#         new_rnd_str += rnd_str[count] + ')'

#     count += 1

#     if count < len(rnd_str):
#         return rec_add_hooks(rnd_str, count, new_rnd_str)

# print(rec_add_hooks(rnd_str))


# def rec(rnd_str):
#     if len(rnd_str) == 1 or len(rnd_str) == 2:
#         return rnd_str
#     return rnd_str[0] + '(' + rec(rnd_str[1:-1]) + ')' + rnd_str[-1]
# print(rec(rnd_str))


# a = [1, [3, [4, [3, 4]], [2, 3, [4]]], 2, [2, 3, 4, [3, 4, [2, 3], 5]]]

# def rec(spicok, level=1):
#     print(*spicok, 'level =', level)
#     for i in spicok:
#         if type(i) == list:
#             rec(i, level + 1)
# rec(a)


# import os
# path = 'C:\\pyTraining\\Тест папка'
# def obxod_file(path, level=1):
#     print('Level =', level, 'Content:', os.listdir(path))
#     for i in os.listdir(path):
#         if os.path.isdir(path + '\\' + i):
#             print('Спускаемся', path + '\\' + i)
#             obxod_file(path + '\\' + i, level + 1)
#             print('Возвращаемся в', path)
# obxod_file(path)


# получить текущую дату и время
# from datetime import datetime as dt
# print(dt.now())

# получить разницу времени между вызовами функции
# from time import perf_counter as pc
# print(pc())

# удобный для восприятия вывод принтов, на примере словаря
# from pprint import pprint
# pprint(locals())

# перезагрузка модуля
# from importlib import reload
# reload(название_модуля)


# класс Counter служит для подсчёта повторений в последовательностях
# from collections import Counter
# s = 'abracadabra'
# w = ['Donald', 'Mickey', 'Donald', 'Mickey', 'Mickey']
# k = (1, 2, 3, 3, 3, 2, 4, 1, 1)
# print(Counter(s))
# print(Counter(w))
# print(Counter(k))


# класс defaultdict служит для исключения ошибки NameError при вызове несуществующего ключа
# при данном вызове создастся ключ с запрошенным именем и значением в виде того что вы передадите в класс defaultdict
# int=0
# list=[]
# str=''
# from collections import defaultdict

# # dct = {}
# # dct['a'] # NameError

# INT = defaultdict(int)
# print(INT)
# INT['s']
# print(INT)

# LST = defaultdict(list)
# print(LST)
# LST['s']
# print(LST)

# STR = defaultdict(str)
# print(STR)
# STR['s']
# print(STR)

# STR = defaultdict(tuple)
# print(STR)
# STR['s']
# print(STR)


# # класс namedtuple, позволяет создавать класс с именованными значениями кортежа
# from collections import namedtuple
# Point = namedtuple('Point', 'x y z')
# pnt = Point(43, 57, 24)
# print(pnt.x, pnt.y, pnt.z)
# print(pnt._asdict()) # представление именнованного кортежа в виде словаря
# print(pnt._replace(y='текст')) # изменение значения атрибута

# # обычный кортеж с обращением по индексам
# point = (43, 57, 24)
# print(point[0], point[1], point[2])

# # ещё пример
# Person = namedtuple('Person', 'name surname date country')
# prsn = Person('Megan', 'Jones', '1998-07-16', 'Bolivia')
# print(prsn.name, prsn.surname, prsn.date, prsn.country)
# print(prsn._asdict())
# print(prsn._replace(date='текст'))

# # обычный кортеж с обращением по индексам
# person = ('Megan', 'Jones', '1998-07-16', 'Bolivia')
# print(person[0], person[1], person[2], person[3])


# # Аннотации, на работу никак не влияют, визуально дают понять к какому типу должен принадлежать объект
# a: int = 100
# # стрелкой указывается тип объекта который должна вернуть функция
# def some(a: int, b: int=40) -> int:
#     return a + b
# print(some(a))
# print(some.__annotations__)

# # с помощью библиотеки typing можно явно указывать какие объекты будут содержатся в итерируемом объекте
# from typing import List, Dict, Set, Tuple, Any, Optional, Union
# d: Dict[str, int] = {'a': 100, 'b': 200}
# # так же для функции
# def some2(lst: List[str]):
#     for item in lst:
#         print(item)
# some2(['a', 'b', 'c'])
# print(some2.__annotations__)

# e: Any = [1, 'a', 'b', 2] # Any означает то что может содержатся любой тип

# def some3(arg: Optional[int]=None): # Optional означает то что arg по дефолту содержит NoneType но опционально может содержать int
#     print(arg)
# some3()
# some3(30)
# print(some3.__annotations__)

# def some4(arg: Union[int, str]): # Union означает то что arg может содержать не менее двух типов
#     print(arg)
# some4(60)
# print(some4.__annotations__)



#########################
# Транслитерация текста #
#########################

# from pytils.translit import translify # pip install pytils
# def transliteration(text):
#     return translify(text).replace(' ', '-').lower()
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# from transliterate import translit # pip install transliterate
# def transliteration(text):
#     return translit(text, reversed=True).replace(' ', '-').lower()
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# from transliterate import slugify # pip install transliterate
# def transliteration(text):
#     slug_text = slugify(text)
#     if not slug_text:
#         text = text.replace(' ', '-').lower()
#         return text
#     return slug_text
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# def transliteration(text):
#     text = text.replace(' ', '-').lower()
#     cyrillic = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
#     latin = 'a|b|v|g|d|e|e|zh|z|i|i|k|l|m|n|o|p|r|s|t|u|f|kh|tc|ch|sh|shch||y||e|iu|ia'.split('|')
#     trantab = {k:v for k, v in zip(cyrillic, latin)}
#     newtext = ''
#     for ch in text:
#         casefunc = str.capitalize if ch.isupper() else str.lower
#         newtext += casefunc(trantab.get(ch.lower(), ch))
#     return newtext
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# Получить прирост в процентах между двух чисел:
# Вычитаем из большего числа меньшее число и делим получившееся число на большее число.
# x = (18 - 11) / 18
# print(x)
# 7 равно 38% прироста

# x = (18 / 11) * 100
# print(x)

# Получить разницу в процентах между числами
# max_row = 108540
# rows_recorded = 20602
# percent_diff = (rows_recorded * 100) / max_row
# print(f'{percent_diff:.1f}')


# MarkDown - Язык разметки
# class MarkDown:
#     """

#     # Заголовок первого уровня.
#     ## Заголовок второго уровня.
#     ### Заголовок третьего уровня.
#     #### Заголовок четвёртого уровня.
#     ##### Заголовок пятого уровня.
#     ###### Заголовок шестого уровня.

#     Ссылка с текстом ссылкой в тултипе
#     [открыть её](https://doka.guide)

#     Ссылка с кастомным текстом в тултипе
#     [открыть её2](https://doka.guide 'Энциклопедия про web-dev')

#     ---
#     Полосы отделяющие визуально

#     ---

#     Разметка в табличном стиле, двоеточие : выравнивает текст внутри колонки

#     |Раз|Два|Три|
#     |:-:|:-:|:-:|
#     |1|Текст1|118|
#     |22|шесть|92|
#     |3|Текст3|7|

#     - текст после минуса

#     - заголовок
#         - подзаголовок1 после табуляции
#         - подзаголовок2 после табуляции

#     >>> Отображение цветных подсказок get_avatar -> str

#     """



# При сравнении пересечения каунтеров, сравниваются значения ключей присутствующих в обоих каунтерах
# тем не менее если в одном из каунтеров будет ключ которого нет в другом он будет проигнорирован при сравнении
# from collections import Counter
# c1 = Counter('aabbcc')
# c2 = Counter('aabbcc')
# c3 = Counter('aabbc')
# c4 = Counter('aabbccdd')
# print(c1, c2, (c1 & c2), (c1 & c2 == c1))
# print(c1, c3, (c1 & c2), (c1 & c3 == c1))
# print(c1, c4, (c1 & c2), (c1 & c4 == c1))



# array = [-4, 2, 5, 6, 18, 19]
# # zip завёрнутый в enumerate
# for index, (l_num, r_num) in enumerate(zip(array, array[1:])):
#     print(index, (l_num, r_num))



# https://docs-python.ru/standart-library/modul-collections-python/klass-deque-modulja-collections/
# from collections import deque
# dq = deque('abcd') # создать список на основе итерируемой последовательности
# print(dq)
# dq.appendleft(44) # добавить элемент в начало списка
# dq.popleft() # удалить первый элемент списка
# dq.extendleft('987') # добавить итерируемую последовательность в начало списка
# print(dq)

# lst = list('abcd')
# print(lst)
# lst.insert(0, 44)
# lst.pop(0)
# print(lst)


# алгоритм поиска в ширину
# from collections import deque
# def search_name_end_letter(name, graph): # O(V+E) # V - количество вершин E - количество рёбер

#     search_queue: deque = deque() # создаём экземпляр очереди
#     search_queue += graph[name] # добавляем в очередь друзей человека с которых начнём поиск
#     searched_persons = [] # этот массив используется для отслеживания уже проверенных людей

#     while search_queue: # пока очередь не пуста
#         person = search_queue.popleft() # из очереди извлекается первый человек

#         if not person in searched_persons: # человек проверяется только в том случае, если он не проверялся ранее

#             if person[-1] == 't': # проверяем заканчивается ли имя у этого человека на букву '?'

#                 # подсчитать количество рёбер/родителей до стартового узла
#                 searched_persons += [name]
#                 def get_parents_count(person, counter=0, persons=[]):
#                     for people in searched_persons:
#                         if person in graph[people]:
#                             print('person:', person)
#                             return get_parents_count(people, counter+1, persons+[person,'-РЕБРО-'])
#                     print('person:', name)
#                     return persons+[name], counter
#                 return get_parents_count(person), 'рёбер'
#                 # return person

#             else: # нет не заканчивается
#                 search_queue += graph[person] # все друзья этого человека добавляются в очередь поиска
#                 searched_persons.append(person) # человек помечается как уже проверенный

#     return False # если выполнение дошло до этой строки, значит, в очереди нет продавца манго

# graph = {
#     'arseniy': ['alice', 'bob', 'claire'],
#     'alice': ['peggy'],
#     'bob': ['anuj', 'peggy'],
#     'claire': ['thom', 'jonny'],
#     'peggy': [],
#     'anuj': [],
#     'thom': ['albert'],
#     'jonny': [],
#     'albert': []
# }
# print('return:', search_name_end_letter('arseniy', graph))



# Тестирование через assert
# def f(a: int, b: int) -> int:
#     return a * b

# def test_f():
#     # если условие не выполняется, в качестве значения у AssertionError
#     # выводится результат выполнения f(2, 2) записаный после запятой
#     assert f(2, 2) == 3, f(2, 2)
# test_f()



# Оценка сложности алгоритмов с помощью нотации - биг O
# биг О - это относительное представление сложности алгоритмов
# https://danielmiessler.com/images/big-o-chart-tutorial-bazar-aymptotic-notations-1.png
# https://wiki.python.org/moin/TimeComplexity

#------------------------------------------------------------------------------------------------------------------#
### Константная сложность: O(1) ###

# если создать объект, распечатать объект, получить сумму и т.д.
# array = [1,2,3,4]
# print(array)
# print(array[-1])
# print(sum(array))
# def f(): pass
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### Логорифмическая сложность: O(log N) ###

# sorted_array = [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# задача найти число 100 в *отсортированном* списке
# если использовать бинарный поиск
# (деление каждого последующего списка по полам и сравнение последнего элемента первой части и первого элемента второй части с искомым числом)
# сложность будет равна: O(log N)

# находим число в пять шагов
# N = 16    # [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# N = 8     # [1,2,5,7,8,11,16,19], [21,22,23,27,28,100,105,203]
# N = 4     # [21,22,23,27], [28,100,105,203]
# N = 2     # [28,100], [105,203] # число найдено за четыре шага из возможных пяти
# N = 1     #

#     /\
#   19  21
#        \
#        /\
#      27  28
#           \
#           /\
#        100  105
#         /

# Двоичный или Бинарный поиск в *отсортированном* списке, в пайтон это список
# print(f'index:  0  1  2  3  4  5   6   7   8   9   10  11  12  13   14   15')
# A = [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# print("array:", A)

# # искомое число
# target = 99

# # объявляем первый последний и центральный индексы
# left = 0
# right = len(A) - 1
# mid = (left + right) // 2

# # Выполняем итерации до тех пор пока значение в списке по индексу mid не станет равным целевому числу
# # и левая граница не встретится с правой
# while A[mid] != target and left < right:

#     # если целевое число больше значения в списке по индексу mid
#     # тогда двигаем левую границу вправо
#     if A[mid] < target:
#         left = mid + 1
#     # иначе двигаем правую границу влево
#     else:
#         right = mid - 1

#     # после того как новые границы определены, заного вычисляем центр
#     mid = (left + right) // 2

# #print(f'{A[mid] = }  {target = }')
# if A[mid] == target:
#     print("target:", target, "index:", mid)
# else:
#     print("target:", target, "not found")


# def binary_search(list, item):
#     low = 0
#     high = len(list) - 1

#     while low <= high:

#         mid = (low + high) // 2

#         if list[mid] == item:
#             return mid

#         if list[mid] > item:
#             high = mid - 1
#         else:
#             low = mid + 1

#     return None

# print(f'index:  0  1  2  3  4  5   6   7   8   9   10  11  12  13   14   15')
# A = [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# print('array:', A)
# print('return index:', binary_search(A, 100))
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### Линейная сложность: O(N) ###

# если пройтись в цикле по какому то списку, N будет равен количеству объектов списка
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 = 10
# N = len(array)
# for i in range(len(array)):
#     summ += array[i]
# print(summ)
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### O(2*N) где 2 количество циклов а N длинна последовательности
# но т.к. в big O natation константы отбрасываются, отбрасываем и получается O(N) ###

# for i in range(10):
#     pass
# for i in range(10):
#     pass
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### Квадратичная сложность: O(N^2) либо другая запись O(N2) ###

# если использовать цикл вложенный в другой цикл, N будет равен количеству объектов списка умноженному на себя 2 раза: 4*4
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 * 4 = 40
# N = 0    # 4 * 4 = 16
# for i in range(len(array)):
#     for j in range(len(array)):
#         summ += array[i]
#         N += 1
# print(summ, N)

# хоть во втором цикле каждый раз мы проходим на 1 элемент меньше всё равно записывается как O(N^2) а не O(N^2/2)
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 * 2 = 20
# N = 0    # (4 * 2) + 2 = 10
# for i in range(len(array)):
#     for j in range(i, len(array)):
#         summ += array[i]
#         N += 1
# print(summ, N)
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### O(N^2+M) где M количество последовательных циклов
# но т.к. в big O natation константы отбрасываются, отбрасываем и получается O(N^2) ###

# for i in range(10):
#     for j in range(10):
#         pass
# for i in range(10):
#     pass
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### Кубическая сложность: O(N^3) либо другая запись O(N3) ###

# если использовать 3 вложенных цикла, N будет равен количеству объектов списка умноженному на себя 3 раза: 4*4*4
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 * 16 = 160
# N = 0 # 4*4*4 = 64
# for i in range(len(array)):
#     for j in range(len(array)):
#         for k in range(len(array)):
#             summ += array[i]
#             N += 1
# print(summ, N)
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### Экспоненциальная сложность: O(2^N) ###

# def get_fib(x):
#     print(x)
#     if x <= 1: return x
#     return get_fib(x - 1) + get_fib(x - 2)
# get_fib(7)
#------------------------------------------------------------------------------------------------------------------#

#------------------------------------------------------------------------------------------------------------------#
### Факториальная сложность: O(N!) ###
# ! означает факториал

# N! = 3   # 3*2*1 = 6
# N! = 5   # 5*4*3*2*1 = 120
#------------------------------------------------------------------------------------------------------------------#



# генерация рандомного hex цвета
# from random import randint
# random_hex_color = '#%06x' % randint(0, 0xFFFFFF)
# print('random_hex_color:', random_hex_color)
# random_hex_color = '#%06X' % randint(0, 256**3-1) # большие буквы
# random_hex_color = '#%06x' % randint(0, 256**3-1) # маленькие буквы
# print('random_hex_color:', random_hex_color, randint(0, 256**3-1))



#                  ASCII TABLE
# +----+-----+----+-----+----+-----+----+-----+
# | Hx | Chr | Hx | Chr | Hx | Chr | Hx | Chr |
# +----+-----+----+-----+----+-----+----+-----+
# | 00 | NUL | 20 | SPC | 40 |  @  | 60 |  `  |
# | 01 | SOH | 21 |  !  | 41 |  A  | 61 |  a  |
# | 02 | STX | 22 |  "  | 42 |  B  | 62 |  b  |
# | 03 | ETX | 23 |  #  | 43 |  C  | 63 |  c  |
# | 04 | EOT | 24 |  $  | 44 |  D  | 64 |  d  |
# | 05 | ENQ | 25 |  %  | 45 |  E  | 65 |  e  |
# | 06 | ACK | 26 |  &  | 46 |  F  | 66 |  f  |
# | 07 | BEL | 27 |  '  | 47 |  G  | 67 |  g  |
# | 08 | BS  | 28 |  (  | 48 |  H  | 68 |  h  |
# | 09 | TAB | 29 |  )  | 49 |  I  | 69 |  i  |
# | 0A | LF  | 2A |  *  | 4A |  J  | 6A |  j  |
# | 0B | VT  | 2B |  +  | 4B |  K  | 6B |  k  |
# | 0C | FF  | 2C |  ,  | 4C |  L  | 6C |  l  |
# | 0D | CR  | 2D |  -  | 4D |  M  | 6D |  m  |
# | 0E | SO  | 2E |  .  | 4E |  N  | 6E |  n  |
# | 0F | SI  | 2F |  /  | 4F |  O  | 6F |  o  |
# | 10 | DLE | 30 |  0  | 50 |  P  | 70 |  p  |
# | 11 | DC1 | 31 |  1  | 51 |  Q  | 71 |  q  |
# | 12 | DC2 | 32 |  2  | 52 |  R  | 72 |  r  |
# | 13 | DC3 | 33 |  3  | 53 |  S  | 73 |  s  |
# | 14 | DC4 | 34 |  4  | 54 |  T  | 74 |  t  |
# | 15 | NAK | 35 |  5  | 55 |  U  | 75 |  u  |
# | 16 | SYN | 36 |  6  | 56 |  V  | 76 |  v  |
# | 17 | ETB | 37 |  7  | 57 |  W  | 77 |  w  |
# | 18 | CAN | 38 |  8  | 58 |  X  | 78 |  x  |
# | 19 | EM  | 39 |  9  | 59 |  Y  | 79 |  y  |
# | 1A | SUB | 3A |  :  | 5A |  Z  | 7A |  z  |
# | 1B | ESC | 3B |  ;  | 5B |  [  | 7B |  {  |
# | 1C | FS  | 3C |  <  | 5C |  \  | 7C |  |  |
# | 1D | GS  | 3D |  =  | 5D |  ]  | 7D |  }  |
# | 1E | RS  | 3E |  >  | 5E |  ^  | 7E |  ~  |
# | 1F | US  | 3F |  ?  | 5F |  _  | 7F | DEL |
# +----+-----+----+-----+----+-----+----+-----+



# тернарный оператор в python
# a = 'a'
# b = 'b'

# condition = True
# result = a if condition else b
# print(result)

# condition = False
# result = a if condition else b
# print(result)



# Работа с системой
# import subprocess
# import os
# process = subprocess.Popen("C:\\Program Files\\Redis\\redis-server.exe", stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
# process = subprocess.Popen("C:\\Program Files\\Redis\\redis-server.exe", stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
# result = subprocess.run(["C:\\Program Files\\Redis\\redis-server.exe"])
# os.startfile(r'C:\Windows\system32\cmd.exe')


# # 1
# if True or True: print(1)
# else: print(2)

# # 1
# if True or False: print(1)
# else: print(2)

# # 1
# if False or True: print(1)
# else: print(2)

# # 2
# if False or False: print(1)
# else: print(2)


# Python может складывать int числа бесконечной длинны (float только короткие)
# a = '9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
# b = '9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
# print(sum(map(int, (a, b))))
# print(int(a) + int(b))






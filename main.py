# типа данных в питоне

#изменяемые(mutable)
# print(type(   {1,2,"a"}  )) #  -> <class 'set'> множество
# print(type(   {"a":1, 2:"b"}   )) #  -> <class 'dict'> словарь
# print(type(   [1,2,"a"]   )) #  -> <class 'list'> список
#
# from array import array
#
# print(type(  array("l", [1,2,4])  )) #  -> <class 'array.array'> массив
#print(type(bytearray(3))) # -> <class 'bytearray'> массив байт

#неизменяемые (unmutable)
# print(type(   1   )) #  -> <class 'int'> Числа
# print(type(   "abc"   )) #  -> <class 'str'> строки
# print(type(   (1,2,"a")  )) #  -> <class 'tuple'> картеж
# print(type(   None  )) #  -> <class 'NoneType'> Нету данных
# print(type(   False  )) #  -> <class 'bool'> Логическое значение
# print(type(   3.4  )) #  -> <class 'float'> дробное число
# print(type(   2 + 4j  )) #  -> <class 'complex'> комплексное число
# print(type(   frozenset([1,2,"a"])  )) #  -> <class 'frozenset'> Неизменяемое множество
#print(type(   bytes(123)   )) #  -> <class 'bytes'> байты

#print(complex(1+3j)) #создание комплексного числа


#узнать id объекта
# print(id( "str" )) # -> 140735957027056
# print( id( (1,2,"a") ) ) # -> 2850657923840

#узнать адрес в памяти в шестнадцатиричном формате
# print(hex(id("str"))) # -> 0x7fffa4b9c8f0
# print(hex(id(123))) # -> 0x7fffa4cff268

# print("123 = ", bytes(123)) # преобразует объект в неизменяемую строку байтов
# print("Привет Мир! =", bytes('Привет Мир!', encoding='utf-8'))

# перевод int в бинарную строку
# print("123 =", bin(123)) # -> 0b1111011
# print("123 =", bin(123)[2:]) # -> 1111011


#изменяемый обект(id и место в памяти объекта всегда одинаковый)
# x = [1,4,"a"]
# print(id(x), x) # -> 1313106120704 [1, 4, 'a']
# x[1] = 6
# print(id(x), x) # -> 1313106120704 [1, 6, 'a']
# x.append("g")
# print(id(x), x) # -> 1313106120704 [1, 6, 'a', 'g']


#неизменяемый объект(любое действие с объектом меняем его id)
# str = "123"
# print(id(str), str) # -> 2866371710448 123
# str = str[:2] + "6"
# print(id(str), str) # -> 2866371710128 126
# str += "5"
# print(id(str), str) # -> 2866371710320 1265


# Области видимости объектов
#built-in # встроенные функции в интерпретаторе, для их использования не нужно импортировать модули, а так же операторы(зарезервированные слова)
#global #объекты доступные в пространтсве имён модуля
#local # объекты достпуные внутри функции
#nonlocal # объекты доступные из блока внешней функции(обёртки)

# def a():
#     ''' Документация функции a '''
#
# class b:
#     ''' Документация класса b '''
#
#     def my_method_only_my():
#         pass
#
# print("Имя объекта", a.__name__, b.__name__) # позволяет посмотреть имя объекта
# print("Документация объекта", a.__doc__, b.__doc__) # позволяет посмотреть документацию объекта
# print(help(a)) # позволяет посмотреть документацию объекта
# print(globals()) # показывает доступные объекты в пространстве имен модуля
# import math
# print(dir(math)) # позволяет узнать какие объекты содержаться в функции/модуле (без аргументов в текущем пространстве имен модуля)
# print(dir(a))
# print(__name__) # узнать какое состояние имеет переменная __name__ в текущем пространстве имен модуля


# print(callable(len), callable("str")) # проверяем является ли объект вызываемым -> True False

# print(locals()) # возвращает словарь с переменными и их значениями из текущей локальной области видимости в виде словаря(dict)

# проверить, относится ли объект к определенному типу данных

# print(isinstance('str', int)) # -> False
# print(isinstance('str', str)) # -> True
#
# #тоже самое, но с помощью type
#
# print(type('str') == int)
# print(type('str') == str)

#принадлежность объекта к определенному сабклассу можно проверить с помощью функции issubclass

# print(issubclass(int, type(72))) # -> True
# print(issubclass(int, type("Hello, world!"))) # -> False
# print(issubclass(str, type("Hello, world!"))) #-> True

#функция type определяет тип данных

# if type(True) == bool:
#     print("boolean")
# if type(1) == int:
#     print(type(1))

# функция bool преобразует число в True или False
#если число == 0 тогда ложь, если число меньше или больше 0 тогда истина
# print(bool(0))
# print(bool(1))
# print(bool(-1))

# так же и со строками, только вместо 0 принимается пустая строка
# print(bool(""))
# print(bool("123"))

#так же и с коллекциями
# print(bool([]))
# print(bool([1,3]))

#умножение разных типов данных
# print(1 * 5) # int -> 5
# print("1" * 5) # str -> "11111"
# print((1,) * 5) # tuple -> (1, 1, 1, 1, 1)
# print([1] * 5) # list -> [1, 1, 1, 1, 1]
# print([[]] * 5) # list -> [[], [], [], [], []]
# print(["1"] * 5) # list -> ['1', '1', '1', '1', '1']
# print(True*5, 1*5)
# print(False*5, 0*5)

# булевые значения можно сумировать если они сумируются в integer object
#         1     0      1     1
# array = [True, False, True, True]
# count = 0
# for i in array:
#     count += i
# print(count, sum(array)) # -> 3 3


# hash можно найти только у неизменяемых типов данных
# print(hash('str')) # -> 4271691589574039315
# print(hash([1,2,3])) # -> TypeError: unhashable type: 'list'

#код можно писать в 1 строку, с помощью ;
# x = 1; y = 2; z = 3
# print(x,y,z) # -> 1 2 3

# в принт можно добавить sep и пробелы между выводимыми объектами будут заменяться на другие символы
# print(1,2,3, sep='a') # -> 1a2a3

#так же можно задать параметр end тем самым убрать перенос строки
# print(1,2,3, end=" ")
# print(4,5,6) # -> 1 2 3 4 5 6


# читабельный вывод словарей с табуляцией
# import json
# print(json.dump(словарь, indent=4, ensure_ascii=False))

# метод str() переводит int в str
# a = 3
# b = 2.4
# c = 'str' + str(a) + str(b)
# print(c) # -> str32.4

#функция input запрашивает пользователя ввод значения с клавиатуры в консоль
#функция int переводит строковое значение(цифровое) в целое числовое
#функция float переводит строковое значение(цифровое) в число с палвающей точкой
# a = int(input("Введите число")) # <- 5
# b = int("5")
# c = float("2.4") + a + b
# print(c) # -> 12.4


# eval может лишь выполнить выражение python
# print(eval("100 + 101")) # -> 201
# print(eval("sum([10,3,23])")) # -> 36
# print(eval("[i for i in range(5)]")) # -> [0, 1, 2, 3, 4]

x,y = 5,5
# print(eval("x != y")) # -> False
# print(eval("x != y", {"x": 5})) # -> NameError: name 'y' is not defined. Если вторым аргументам в евал передавать словарь, то он будет видеть только переменные из словаря, в словаре можно переоьъявить глобальные пременные

# с помощью compile можно выражение занести в объект
# code = compile("4+5", "<string>", "eval")
# print(eval(code)) # -> 9

# с помощью exec() можно выполнить любой блок когда python
# exec("if 1 > 0: print('Yes 1 > 0')") # -> Yes 1 > 0

#операторы условий
# if
# elif
# else
# :
# pass # заглушка, нужна для того чтобы не писать print() после объявление условий или функции или ``` ```
# ... # работает так же как заглушка
# del # оператор удаление объекта

# логические операторы(имеют приоритет выполнение)
# not # 1
# and # 2
# or # 3

#contiune нужен для того, что бы пропускать итерацию цикла и начинать следующую с самого начала
# break оператор для работы с циклами, нужен для того, чтобы завершать цикл и выходить из тела цикла
# else  оператор для работы с циклами, сработает в том случае если все итерации цикла завершены

# i = 0
# print("==> IN")
# while i < 10:
# 	i += 1
# 	if 3 < i < 6:
# 		print("i=", i, "contiune")
# 		continue
# 	print("i=", i)
# 	if i == 8:
# 		print("i=", i, "break")
# 		break
# else:
# 	print("else worked")
# print("==> OUT")


# Убираем повторяющиеся элементы из списка с помощью цикла
# a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
# b = []
# for i in a:
# 	if not i in b:
# 		b.append(i)
# print(a)
# print(b)
# print(list(set(a))) # аналогичное решение задачи


# сортировка строки по маленьким/большим буквам и не буквенным символам с помощью цикла
# s = 'h@lLo WOrld!'
#
# for i in s:
# 	if "a" <= i <= "z":
# 		print(i, 'small')
# 	elif "A" <= i <= "Z":
# 		print(i, "BIG")
# 	else:
# 		print(i, "not word")


# подсчет повторяющихся символов в строке с помощью цикла
# x = 'frsncsIU$WB$Csfnsdfoisnfcweopfcfsdlfnweocgiroenc'
# result = {}
# for i in x:
# 	try:
# 		result[i] += 1
# 	except:
# 		result[i] = 1
# print(result)

# Операторы сравнений (Проверяют объекты на равенство их значений)
# ==
# <
# >
# <=
# >=
# !=

# построение диапазона значений

# x = 4
# if 2 <= x <= 10:
# 	print("х в диапазоне от 2 до 10")

# опеароты сравнений можно записать в цеопчкке
# x,y,z = 1,1,1
#
# if x == y == z:
# 	print("все числа равны")

# оператор in если объект совпадает хотя бы частично с другим объектов тогда выдает True
# x = "abc"
# y = "adcs"
# z = "abcd"
# print(x in z) # -> True
# print(y in z) # -> False

# оператор is если объекты ссылаются на одну и ту же ячейку памяти, тогда True
# x = 10
# y = int("10")
# print(x is y) # -> True


# для слишком больших чисел выделяется отдельная область в памяти
# x = 31**25
# y = 31**25
# print(x, x is y) # True
# a = 26**26
# b = 26**26
# print(a, a is b) # False


#для списков выделяется отдельная область в памяти
# x = [1,2,3]
# y = [1,2,3]
# z = x
# print(x is y) # -> False
# print(x is z) # -> True
# print(y is z) # -> False

# самое большое число в питоне float('inf'), он действует как неограниченное верхнее значение
# print(float('inf') > 99999999999**999999) # -> True


# Математические операторы (имеют приоритет выполнения)
# a = 10 + 5
# a = 10 - 5
# a = 10 * 5
# a = 19 / 5 # обычное деление, ответ = 3.8
# a = 19 // 5 # деление с отбросом остатка после точки (в числе 19 число 5 помещается 3 раза)
# Остаток от деления 19 % 7 в число 19 число семь помещается 2 раза, остаток = 5

#найти числа кратные 4
# for i in range(50):
#     if i % 4 == 0:
#         print(i)


#операции с числами

#функция sum() сумирует все числа в списке
# print(sum([1,2,3,4,5])) # -> 15

#функция abs() переводит число из отрицательного в положительное
# print(abs(-12)) # -> 12

#функция min() находит наименьшее число из списка
# print(min([2,4,6,2,1,0,-2,-54,-1])) # -> -54

#функция max() находит наибольшее число из списка
# print(max([2,4,6,2,1,0,-2,-54,-1])) # -> 6

#функция pow() возводит число в степень
# print(pow(5,5), 5**5) # -> 3125 3125

#функция round() округляет число в плавающей точкой в большую или меньшую сторону в зависимости куда ближе, так же можно вторым аргументом передать, сколько оставить цифр после запятой
# (round(5.6342)) # -> 6
# print(round(5.27234, 1)) # -> 5.3

import math
#функция math.ceil окргуляет число всегда в большую сторону
# print(math.ceil(5.3)) # -> 6

#функция math.floor окргуляет число всегда в меньшую сторону
# print(math.floor(5.9)) # -> 5

#функция math.trunc убирает цифры после точки, работает аналогично int()
# print(math.trunc(5.7)) # -> 5

#math.pi - число pi
# print(math.pi) # -> 3.141592653589793

#разделение числа по цифрам c помощью математических операторов
# x=3456
#
# n1 = x // 1000
# n2 = x // 100 % 10
# n3 = x // 10 % 10
# n4 = x % 10
# print(n1, n2 ,n3 ,n4)

#программа открывающая сайт
# import os
# while True:
#     sait = input()
#     if "https://" in sait:
#         os.system("start " + sait)
#         break

#модуль рандом
# import random
# for i in range(20):
#     print(random.randrange(1, 100))

# while оператор цикла исполняется (пока условие верно)
# цикл от 1 до 5
# можно подключить оператор else который сработает по завершению цикла
# a = 0
# while a < 5 :
# 	a += 1
# 	print(a)
# else :
# 	print("finish")

#цикл for
# x = [1,2,3,4,5,6]
# for i in x[3:]:
#     print(i) # -> 4 5 6

# итерация элементов в итерируемом объекте с помощью функций iter() next()
# x = range(5)
# print(x, type(x)) # -> range(0, 5) <class 'range'>
#
# it = iter(x)
# it = x.__iter__() # тоже самое - другая запись
# print(it, type(it))
#
# n1 = next(it)
# n2 = it.__next__()
# n3 = next(it)
# n4 = next(it)
# n5 = next(it)
# print(n1,n2,n3,n4,n5) # -> 0 1 2 3 4

# если элементы закончились и еще раз прописать next() то выйдет исключение StopIteration


# функция zip() упаковывает элементы из 2-х списков в кортеж, [ (a[0], b[0]) , (a[1], b[1]) ]
# a = [5,6,7]
# b = [100,200,300, 400]
#
# zp = zip(a,b)
# print(zp,type(zp), list(zp)) # -> <zip object at 0x000001A662F94D40> <class 'zip'> [(5, 100), (6, 200), (7, 300)]


#########################################################################################
# Список (list) упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#########################################################################################

# индексация с конца            -4              -3                -2               -1
# индексация с начала            0               1                 2                3
# x = [1,2,3,'abc', [123,123,321], (1,3,5)]
#
# #узнать длины списка можно с помощью функции len()
# print(x[0], len(x)) # -> 1 6
#
# #без исключения обратиться к последнему элементу списка(если он пустой)
# # lst = []
# # x = lst[-1:] or None
# # print(x)
#
# #можно обращаться ко вложенным списка
# print(x[4][0]) # -> 123
#
# #можно перезаписывать определенную ячейку списка
# x[0] = 5
# print(x)
#
# #можно менять переменные местами множественным присваиванием
# x[0], x[2] = x[2], x[0]
# print(x)
#
# #можно добавить данные в список
# x = x + [[1,2,3]]
# print(x)

#функция list() разбивает строку по 1-му символу в лист
# x = list("abcdfsdf")
# print(x)

# сравнение списков (при этом происходит поочередное сравнение каждого элемента списка слева на право)
# print('[1] <= [1]', [1] <= [1]) # -> True
# print('[2] <= [1]', [2] <= [1]) # -> False
# print('[1, 1] <= [1, 1]', [1, 1] <= [1, 1]) # -> True
# print('[1, 2] <= [1, 1]', [1, 2] <= [1, 1]) # -> False

#методы для работы со списками

# x = [1,2,3,4,5]
# #узнаем есть ли значение в промежутке списка от 1 до 4
# print(3 in x[1:4]) # -> True
#
# #узнать длины списка можно с помощью функции len()
# print(len(x)) # -> 5
#
# # .append() добавляет элемент в конец списка
# # x.append("qwe")
# # print(x) # -> [1, 2, 3, 4, 5, 'qwe']
#
# # .insert() вставляет элемент в указанный индекс
# # x.insert(0, "5")
# # print(x) # -> ['5', 1, 2, 3, 4, 5, 'qwe']
#
# # .count() подсчитывает сколько одинаковых элементов в списке по значению
# print(x.count(5)) # -> 1
#
# # .index() узнаем индекс элемента по его имени
# print(x.index(5)) # -> 5 (2 arg = с какого индекса начать поиск 3arg = до какого индекса искать)
#
# # .sort() сортирует список по возрастанию, если добавить reverse=True список отсортируется по убыванию
# # так же есть 2 аргумент key=func, чтобы менять принцип сортировки
# x.sort(reverse=True)
# print(x) # -> [5, 4, 3, 2, 1]
# c = sorted(x, key=abs) # возвращает новый отсортированый список, не трогая родительский
# print(c) # -> [1, 2, 3, 4, 5]
#
# # .reverse() инвертирует список и перезаписывает его в ту же ячейку памяти
# print("1:", x)
# x.reverse()
# print("2:", x)
#
# #reversed() создает итератор с инвертированными элементами
# # (аналогично x = list('98765') x.reverse() print(x))
# print(reversed("74452"))
#
# # .pop удаляет элемент по указанному индексу (если указать переменную, то сохранит удаленный элемент в переменную)(без аргументов удаляет элемент в конце списка)
# xd = x.pop(0)
# print(x, xd) # -> [2, 3, 4, 5] 1
#
# # .remove() удаляет элемент по его имени
# x.remove(2)
# print(x) # -> [3, 4, 5]
#
# # .clear() полностью очищает список
# x.clear()
# print(x) # -> []
#
# # .extend() распаковывает список в конец списка
# x.extend(["123", 'wp', 123])
# print(x) # -> ['123', 'wp', 123]
#
# # .copy() копирует список в переменную
# xc = x.copy()
# print(xc) # -> ['123', 'wp', 123]
# #analog
# xc1 = x[:]
# xc2 = list(x)
# print(xc1, xc2) # -> ['123', 'wp', 123] ['123', 'wp', 123]
#
# #списки можно складывать
# x = ['Hello']+['world']+['!']
# print(x) # -> ['Hello', 'world', '!']
#
# #переводим список обратно в строку
# text = '_'.join(x)
# print(text) # -> Hello_world_!

# a = list(range(10))
# b = []
# for i in a:
#     if i == (5 or 6):
#         continue
#     b.append(i)
# else:
#     print(b)
#
# # в списках можно использовать срезы, также как и в строках
#
# #если нам нужно скопировать список, то используем метод copy()
# c = a.copy()
# #либо более точное средство(синтаксис срезов)[start:stop:step]
# c = a[::] # -> [0, 1, 2, 3, 4, 6, 7, 8, 9]
# #заменяем цикл одной строчкой
# c = a[0::2] # получаем только нечетные индексы # -> [0,2,4,6,8]
# c = a[1::2] # получаем только четные индексы # -> [1,3,5,7,9]
# c = a[:5] # получаем список до 5 индекса включительно # -> [0,1,2,3,4]
#
# # заменяем первые 2 элемента на значения из нового списка
# c[:2] = ["a", "b"] # -> ['a', 'b', 2, 3, 4]
#
# # удалить значение по индексы
# del c[2] # -> ['a', 'b', 3, 4]
# print(c)
#
# # удаляем из списка все четне числа и заносим их в новый список
#
# for i in a:
#     if i % 2 == 0:
#         a.remove(i)
#         b.append(i)
# else:
#     print(a, b)


#######################################################################################################
# Кортеж (tuple) неизменяемая упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#######################################################################################################

# создание кортежа без помощи круглых скобок с одним значением и запятой
# x = 1,
# print(x, type(x))

#создание кортежа, скобки дают наглядное представление, что это кортеж
# x = (1,2,3)
# print(x)
#присвоение значений из кортежа в переменные
# a,b,c = x
# print(a,b,c)

# создание пустого кортежа
# x = ()
# print(x)
# x = tuple() # аналог
# print(x)

#для создание кортежа можно использовать любую итерабельную последовательность
# print(tuple([1,2,3]), tuple({"a":1, "b":2}), tuple({1,2,3}), tuple((1,2,3)), tuple("123"), tuple(range(3))) # -> (1, 2, 3) ('a', 'b') (1, 2, 3) (1, 2, 3) ('1', '2', '3') (0, 1, 2)

#кортеж имеет индексацию по аналогии со списками
# x = tuple(range(4))
# print(x[2])


#хоть кортеж и является не изменным, но если в нем содержится изменяемый тип данных, то мы можем изменить его
# x = (1,2,[1,2])
# x[2].append(2)
# print(x) # -> (1, 2, [1, 2, 2])

#кортеж можно использовать в качестве ключа для словаря
# x = 1,2,3
# b = {}
# b[x] = 123
# print(b) # -> {(1, 2, 3): 123}

#у кортежа очень мало методов, поэтому можно преобразовать его в список - изменить - преобразовать обратно
# x = (1,2,3,4,5,6)
# x1 = list(x)
# x1[0] = -1
# x1.append(7)
# x2 = tuple(x1)
# print(x2) # -> (-1, 2, 3, 4, 5, 6, 7)

#обращение к элементу кортежа по индексу
# x = ("i", "love", "u")
# print(x[1]) # -> love

#к кортежу можно применять срез
# x = (1,2,3,4,5,6)
# # print(x[1:3]) # -> (2, 3)

#кортежи можно складывать
# x = (1,2)
# x1 = (3,4,5,6)
# print(x + x1) # -> (1, 2, 3, 4, 5, 6)

#кортежи можно умножать
# x = (1,2,3)
# print(x * 2) # -> (1, 2, 3, 1, 2, 3)

#с помощью in можно проверить находится ли объект в кортеже
# x = ('a', 'b', 'c')
# print( 'a' in x , 'n' in x ) # -> True False

#функция enuerate превращает каждый элемент в кортеж, состоязий из индекса и значение
#может принимать 2арг, в котором указывается, с какого индекса начинать
# print(list(enumerate([1,2,3,4,5], 111))) # -> [(111, 1), (112, 2), (113, 3), (114, 4), (115, 5)]

# dct = {"111": 10, "112": 11}
# for index, value in enumerate(dct):
#     print(index, value) # -> 0 111, 1 112

#########################################
# Методы для работы с кортежами (tuple) #
#########################################
# x = (1,2,3,4,5)
#
# print(len(x)) # -> 5
# print(x.count(1)) # -> 1
# print(x.index(4)) # -> 3
# print(sorted(x, reverse=True)) # -> [5,4,3,2,1]

################################### Блок Кортежа закончен ###################################

######################
# Работа с функциями #
######################

#функция определения каллорийности

# def calorie_calculate(name, get_calorie, spend_calorie):
#     if get_calorie > spend_calorie:
#         msg = name + " getting fat"
#     else:
#         msg = name + " lose weight"
#     return msg

# print(calorie_calculate("Ivan", 1200, 1300)) # -> Ivan lose weight
# persone = ["Slava", 1300, 1200]
# #в функцию можно передавать список со значениями, указав * перед списком
# print(calorie_calculate(*persone)) # -> Slava getting fat


#return возвращает значени в точку запуска функции name_func()
#
# def qwe():
#     x = 2 + z
#     return x
#
# z = 3
# #переменные должны объявляться выше вызываемой функции связанной с этими переменными
# y = qwe()
# print(y) # -> 5
# #взаимодейстовать с переменной x можно только через return
# y = qwe() + 1
# print(y) # -> 6

# в функцие можно указывать дефолтные аргументы и давать им значения
# def count_list(list, boolean = False, count = 0):
#     if boolean == True:
#         typelist = type(list[5]) # узнаем тип элемента списка
#         for i in list:
#            count += 1 #узнаем сколько элементов в списке
#         return count, typelist
#     else:
#         for i in list:
#             count += 1
#         return count
#
# j = [9, 8, 7, 6, "a", 0.4, True]
# h,p = count_list(j, True)
# print(h,p) # -> 7 <class 'float'>

# если нужно распокавать больше значений чем переменных, тогда остальные значение попадут в переменную-лист со *
# *x, y, z = 2, 3
# # print(x,y,z) # -> [] 2 3
# #
# # x, *y, z = 2,3
# # print(x,y,z) # -> 2 [] 3
# #
# # x,y, *z = 2,3
# # print(x,y,z) # -> 2 3 []
# #
# # *x, y, z = 1 ,2,3,4,5,6,7,8
# # print(x,y,z) # -> [1, 2, 3, 4, 5, 6] 7 8

#если перед аргументом поставить * то все аргумента после него превратяться в кортеж, можно записать аргументы после кортежа, если указать в вызове имя аргумента и значение

# def name(h,d, *args, key1, key2):
#     print(h) # -> 1
#     print(d) # -> 2
#     print(args) # -> (3,4,5)
#     print(key1) # -> 6
#     print(key2) # -> 7
#
# name(1,2,3,4,5,key1=6, key2=7)

#функция возвращает по 1 элементы без повторений
# def exclusive_item(*args, key=True):
#     newlist = []
#     for i in args:
#         for y in i:
#             if y not in newlist:
#                 newlist.append(y)
#     if key:
#         newlist.sort()
#     return newlist
#
# print(exclusive_item([3,1,5,7,2,4,2])) # -> [1, 2, 3, 4, 5, 7]


#args=arguments
# def print_ab(a,b, *args):
#     print(a)
#     print(b)
#     print(args)
#
# #передача списка спомощью спец. символа * разбивает его поэлементно и отправляет каждый элемент в виде отдельного аргумента
# x = [1,2,3,4,5,6,7]
# print_ab(*x) 1 2 (3, 4, 5, 6, 7)
# # Если не угадать с количеством передаваемых элементов и объявленых аргументов в функции
# # то получим исключение TypeError, что бы не прописывать каждый аргумент в функции, можно
# # воспользоваться спец символом * уже в функции для включения всех полученных элементов в один кортеж

#kwargs = keyword arguments
# # если между позиционными a, b и запакованными **kwargs стоит слеш то аргументы из **kwargs автоматически не перейдут в a, b
# def print_ab2(a, b, /,**kwargs):
#     print(a)
#     print(b)
#     print(kwargs)
#
# #таким же способ можно передавать с помощью * ключи словаря, а с помощью ** значения словаря
# dct = {'a':10, 'b':20, 'c':30, 'd':40}
# print_ab2(**dct)
# print_ab2(1, 2, c=10, d=20)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#перезаписываем элементы которые объявлены вне функции с помощью global
# x = 5
# def qwe():
#     global x
#     x = 10
# print(x) # -> 5
# qwe()
# print(x) # -> 10

#аналог global но можно использовать только во вложенной функции nonlocal

# x = 5
# def qwe():
#     x=10
#     print(x) # -> 10
#     def qwe1():
#         nonlocal x
#         x = 15
#         print(x) # -> 15
#     qwe1()
#     print(x) # -> 15
# print(x) # -> 5
# qwe()
# print(x) # -> 5

# #Вычисляем объем цилиндра
# import math
# #Контсанты принято записывать в верхнем регистре
# PI = math.pi
#
# def get_radius():
#     return float(input("Введите Радиус цилиндра"))
#
# def get_height():
#     return float(input("Введите высоту цилиндра"))
#
# def get_v():
#     r = get_radius()
#     h = get_height()
#     s = PI * r ** 2
#     v = s * h
#     return v
#
# print("Объем цилиндра:", get_v(), "см3")



##################################################################################################
# Словарь (dict) изменяемая неупорядоченная коллекция произвольных элементов с доступом по ключу #
# иногда ещё называют ассоциативным списком или хеш-таблицей.                                   #
# в словаре данные всегда привязаны к ключу                                                      #
#                                                                                                #
# ключём в словаре могут быть только неизменяемые типы данных,                                   #
# если в кортеже содержится изменяемый тип данных то кортеж не может быть ключём.                #
##################################################################################################



# d = {}
# tpl = ((1, 2, (1, 2, [1, 2])), 1, 2)
# # для ключа словаря можно использовать только полностью не изменяемые типы данных
# # даже глубоко вложенный изменяемый тип данных - список - вызовет ошибку: TypeError: unhashable type: 'list'
# d[tpl] = 'test'

# dict1 = {}
# not_mutable_tuple = (1,2,(1,3))
# dict1[not_mutable_tuple] = "text"
# print(dict1)

# #Создаем пустой словарь
# dict1 = {}
# #с помощью функции
# dict2 = dict()
# print(dict2)

# d1 = {"name": "Ivan", "lang": "ru"}
# print(d1) # -> {'name': 'Ivan', 'lang': 'ru'}
# d2 = dict(name="Ivan", lang="ru")
# print(d2) # -> {'name': 'Ivan', 'lang': 'ru'}


# #Вызов по ключу
# d = {"a": 5}
# print(d["a"]) # -> 5
# #Добавление новое ключ-значение в словарь
# d["b"] = 6
# print(d) # -> {'a': 5, 'b': 6}
# #Изменение существующего значение через ключ
# d["a"] = 3
# print(d) # -> {'a': 3, 'b': 6}
# #Удаление элемента по ключу
# del d["a"]
# print(d) # -> {'b': 6}

# print(dict(odin=1, dva=2)) # -> {'odin': 1, 'dva': 2}
# print(dict([["odin",1], ["dva", 2]])) # -> {'odin': 1, 'dva': 2}


# Заменяем ключ в словаре
# new_dict = { str(k).replace(str('какой_то_ключ'), 'заменяем_на_этот_ключ'): v for k, v in old_dict.items() }


#при сравнении словарей сравниваются как ключи так и их значения
# d1 = {'a':4, 'b':4}
# d2 = {'a':4, 'b':4}
# d3 = {'a':4, 'b':3}
# print(d1 == d2, d1 == d3) # -> True False

# сравнить только ключи
# print(d1.keys() == d2.keys(), d1.keys() == d3.keys())


#########################################
# Методы для работы со словарями (dict) #
#########################################

d1 = {1:'one', 2:'two', 3:'three', 4:'four'}

# print(dict.fromkeys([1,2,3,4,5], "qwe")) # -> {1: 'qwe', 2: 'qwe', 3: 'qwe', 4: 'qwe', 5: 'qwe'}
#
# d1.clear() # - очищает полностью словарь
# print(d1) # -> {}

#get выводит значение по ключу, как и вызов через квадратные скобки, но если значения не будет, то выдаст none
# print(d1.get(3)) # ->  three

#2 аргумент будет заменять none на 2арг
# print(d1.get(7, "netu")) # -> netu

# setdefault Возвращает значение выбранного ключа, если такого ключа нету создаёт ключ со значением None и так же возвращает None.
# Если указать через запятую своё значение то оно запишеться вместо None и оно же вернётся

# print(d1.setdefault(11, "qwe")) # -> qwe
# print(d1) # -> {1: 'one', 2: 'two', 3: 'three', 4: 'four', 11: 'qwe'}

# print(d1.pop(3)) # удаляет пару ключ:значение и возвращает значение удалённой пары, является аналогом del словарь[ключ]
# print(d1.popitem()) # удаляет случайную пару и возвращает ключ:значение удалённой пары


#dict.items() возвращает список с кортежами ключ:значение, нужно для работы с циклом фор
# print(d1.items()) # -> dict_items([(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')])
#
# print(d1.keys()) # возвращает ключи в виде списка (нужен для работы с циклом for) может использоваться как множество, т.к. ключи уникальны
# print(d1.values()) # возващает значения в виде списка (нужен для работы с циклом for)

# new_d = {2:'перезаписали значение двойки', 'профессия':'программист'}
# print(d1) # -> {1: 'one', 2: 'two', 3: 'three', 4: 'four'}
# d1.update(new_d) # добавить пары ключ:значение из одного словаря в другой, если ключи уже существуют их значения будут перезаписаны
# print(d1) # -> {1: 'one', 2: 'перезаписали значение двойки', 3: 'three', 4: 'four', 'профессия': 'программист'}

# a = d1.copy() # создаёт копию словаря в новой переменной
# print(len(d1)) # узнать количество пар в словаре
# print(2 in d1) # узнать есть ли такой ключ в словаре

# print(sorted(d1, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)


# Контекстный менеджер with автоматически закрывает файл после работы с ним
# with open('C:\\Users\\pokam\\Desktop\\Новый текстовый документ (15).txt', 'r') as file:
#     text = file.read()
#     print(text)


# text = file.read() # прочитать весь файл целиком
# text = file.readline() # прочитать файл построчно
# text = file.readlines() # прочитать файл построчно и передать данные в переменную в виде списка
# text = file.write('строка текста') # записать в файл строку текста
# print(text)
# file.close() # закрыть файл

# 'r' Открыть для чтения (по умолчанию если не указывать параметр)
# 'w' Открыть для записи, содержимое файла удаляется, если файла нет, создаётся новый
# 'x' Открытие на запись, если файла не существует, иначе исключение.
# 'a' Открыть для дозаписи в конец файла, если файла нет, создаётся новый
# 't' Открыть в текстовом режиме (по умолчанию если не указывать параметр)
# 'b' Открыть в бинарном режиме (двоичном) 'rb', 'wb', 'ab'
# '+' Открыть для чтения и записи 'r+', 'w+', 'a+'


# запись текста в файл
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt', 'w')
# print(file)
# # file.write('текста строка')
# file.close()

# чтение текста из файла
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt')
# text = file.read()
# # text = file.read(5) # если указать число в функции read() можно прочитать определенное количество символов
# # text = file.seek(0) # указав число в функции seek() мы переместимся на чтение с указанного номера символа
# print(text)
# file.close()



#######################################################################################################
# Множество (set) неупорядоченная коллекция уникальных элементов (отсутствуют повторяющиеся значения) #
# может состоять только из неизменяемых типов данных: число, строка, кортеж                           #
#######################################################################################################

#создать set можно с помощью {} скобок
# a = {1,2,2,2,4,5,6,3,4,5,6,6} # выглядит как дикт, но если указывая значения через запятую, то будет множество
# print(a, type(a)) # -> {1, 2, 3, 4, 5, 6} <class 'set'>
#так же можно создать с помощью set()
# a = set()
# print(a, type(a)) # -> set() <class 'set'>

# преобразуем список с повторяющимися значениями в множество затем обратно в список, тем самым убирая повторяющиеся значения
# print(list(set([1, 1, 2, 2, 3, 3, 4, 4, 5, 5])))


# x_tuple = (1, 2, 3, 4, 5, 6, 7)
# x_list = [1, 2, 3, 4, 5, 6, 7]
# x_dict = {'1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7}
# x_set = {1, 2, 3, 4, 5, 6, 7} # множества работают гораздо быстрее чем остальные типы списков
# # размер списка в памяти
# print(x_tuple.__sizeof__()) # 80
# print(x_list.__sizeof__()) # 96
# print(x_dict.__sizeof__()) # 344
# print(x_set.__sizeof__(), '\n') # 712
# from sys import getsizeof
# print(getsizeof(x_tuple)) # 80
# print(getsizeof(x_list)) # 96
# print(getsizeof(x_dict)) # 344
# print(getsizeof(x_set)) # 712


##########################################
# Методы для работы со множествами (set) #
##########################################

# z = {1, 2, 3, 4, 5}
# x = {3, 4, 5, 6, 7}
#
# # при добавлении или объединении значения которые повторяются не будут дублироваться
# z.add(6)
# print(z)
# z.update([7, 8]) # добавить значения из итерабильного объекта в множество
# z.update((9, 10))
# z.update({11, 12})
# z.update('ABCD') # добавляет в рандомном порядке
# print(z)

# y = z.union(x) # объединить множества # аналог y = z | x
# print(y) # -> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'D', 'B', 'A'}
# z = z.union(x) # перезаписать объединённые множества в z # аналог z |= x
# print(z) # -> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'D', 'B', 'A'}

# z.discard(4) # удалить один элемент из множества (ничего не делает если такого элемента нет)
# print(z) # -> {1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'D', 'B', 'A'}

# z.remove(6) # удалить один элемент из множества (дропает исключение KeyError если такого элемента нет)
# print(z)

# z.pop() # удалить первый элемент из множества,
# print(z) # -> {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'B', 'D', 'A'}

# y = z.intersection(x) # получить повторяющиеся элементы в двух множествах # аналог y = z & x
# print(y) # -> {3, 4, 5, 6, 7}

# z.intersection_update(x) # перезаписать в z пересечение значений # аналог z &= x
# print(z) # -> {3, 4, 5, 6, 7}

# y = z.difference(x) # получить не повторяющиеся элементы из первого множества
# print(y) # -> {1, 2, 'B', 'C', 8, 9, 10, 11, 12, 'D', 'A'}

# z.difference_update(x) # перезаписать в z не повторяющиеся элементы из первого множества # аналог ^=

# print(z ^ x) # получить не повторяющиеся элементы из первого и второго множества одновременно

# print(z - x) # вычесть значения одного множества из значений другого множества

# z.issubset(x) # или  z <= x  все элементы z принадлежат x.
# z.issuperset(x) # или  z >= x  аналогично.
# z.isdisjoint(x) # истина, если z и x не имеют общих элементов.

# print(sorted(z, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)


###############################################################################################
# Строка (str) упорядоченная последовательность символов (присутствуют повторяющиеся символы) #
###############################################################################################


# поставив обратный слэш перед кавычками можно экранировать их
# тем самым вывести этот символ просто в качестве визуального элемента
# print("Я \"Иван\" всем привет!")
# print('Я "Иван" всем привет!')


# перенос строки на следующую строку (просто для оптимизации места на экране) (так же работает и для обычного кода)
# s = "qwerty\
# uiopa\
# sdfgh\
# jklzx\
# cvbnm"
# print(s)


# аналог переноса строки с помощью тройных кавчек (""", ''', ```)
# s = """qwerty
# uiopa
# sdfgh
# jklzx
# cvbnm"""
# print(s)


# строки могут сами конкатенироватся даже без '+'
# a = 'первый ' 'второй '   'третий'
# print(a)
# b = ('четвёртый '
#      'пятый '
#      'шестой')
# print(b)


# \n позволяет переносить строку на следующую по настоящему

# экранирование переноса строки изза \n с помощью второго слэша
# x = "https:\www.youtube.com\nexttab"
# x = "https:\www.youtube.com\\nexttab"

# специальный символ r перед строкой запрещает применять управляющие символы в данной строке
# x = r"https:\www.youtube.com\nexttab"
# для работы с путями в виндовс можно использовать r либо везде ставить двойной слэш
# x = 'C:\\Users\\PyHS\\Desktop'
# print(x)


# print('\f \v') # гендерные символы

# print('123\r456') # \r возврат в начало текущей строки
# print('123\b\b456') # \b возврат на один символ назад в текущей строке

# Сравнение строк
# print('abc' > 'r') # Получим False т.к. сравнение начинается с 1 символа а 'r' имеет больший порядковый номер чем 'a'
# print(ord('a'), ord('r'), ord('2'), ord('7')) # функция ord позволяет узнать номер символа в таблице ASCII
# print(chr(ord('a')), chr(ord('r'))) # функция chr наоборот переводит номер символа в сам символ
# print('abc' < 'abcd') # если символы в строках одинаковые но одна строка длиннее другой то True будет на стороне более длинной строки

# s = "stroka texta"
# print(s[5]) # получаем конкретный символ по индексу
# print(s[2:6]) # срез строки со 2 по 6 символ
# print(s[3:]) # срез с левой стороны
# print(s[:9]) # срез с правой стороны
# print(s[::2]) # срез символов через символ
# print(s[::-1]) # инвертируем строку с помощью среза

# инвертируем строку любой длинны с помощью цикла
# cat = 'Кошка'
# tac_table = []
# count = 0
#
# for letter in range(0, len(cat)):
#     count -= 1
#     tac_table.append(cat[count])
#
# inverseCat = ''.join(tac_table)
# print(inverseCat)


#######################################
# Методы для работы со строками (str) #
#######################################

s = 'Привет мир! Как дела народ?'
# уточнение для методов (find, rindex, count) индексация всегда идёт слева на право
# если указанного символа нет в тексте (find вернёт -1)(index вернёт ValueError)(count вернёт 0)
# (find, index, count) могут принимать доп арг. start, stop с какого и до какого индекса
# print(s.find('д')) # возвращает индекс первого попавшегося искомого символа либо строки из нескольких символов # метод rfind() ищет первый попавшийся символ справа на лево
# print(s.rindex('д')) # идентично с find просто может сыпать разные эрроры # rindex()
# print(s.count('д')) # узнать количество определенных символов
# print(len(s)) # узнать количество всех символов в строке
# print(s.upper()) # переводит все символы в верхний регистр
# print(s.lower()) # переводит все символы в нижний регистр
# print('a'.isupper(), 'A'.islower()) # проверит принадлежит ли символ к проверяемому регистру, вернёт булевое значение
# print('a'.swapcase(), 'A'.swapcase()) # меняет регистр на противоположный (переводит символы верхнего регистра в нижний регистр, а символы нижнего регистра в верхний регистр)
# print(s.capitalize()) # переводит первую букву в строке в верхний регистр а все остальные в нижний регистр
# print(s.title()) # переводит первую букву во всех словах в строке в верхний регистр
# print(s.istitle()) # если в строке большая буква только первая возвращает True иначе False
# print(s.strip()) # по дефолту удаляет неограниченное количество пробелов и преносов строк в начале и конце строки
# если указать символ он сделает тоже самое только с ним. Ещё методы которые убирают только с левой либо с правой стороны (lstrip, rstrip)
# print(s.isalpha()) # если символы являются только буквами возвращает True, иначе False
# print(s.isdigit()) # если символы являются только числами возвращает True, иначе False
# print(s.isalnum()) # если строка состоит из букв либо цифр или из букв вместе цифрами возвращает True иначе False
# print(s.replace('е', ' ^_^', 1)) # заменяет выбранный символ на другой, может принимать 3 арг. сколько замен надо произвести
# print(s.split('а')) # разделяет строку на сектора по выбранному символу и возвращает их в виде списка (по умолчанию по пробелам)
# print('111'.rjust(7, '$')) # вставляет символ заполнитель слева от строки # ljust аналогично только справа (по умолчанию заполн. пробел)
# print('abcd'.startswith('ab'), 'abcd'.startswith('ba')) # сравнивает указанный префикс с началом строки возвращает True если префикс совпадает
# print('abcd'.endswith('cd'), 'abcd'.endswith('dc')) # сравнивает указанный префикс с концом строки возвращает True если префикс совпадает

# print(reversed('98765')) # создаёт итератор с инвертированными элементами
# print(''.join(list(reversed('98765')))) # пример

# print(repr("строка вместе с одинарными кавычками\n\nЭ")) # возвращает строку вместе с кавычками и управляющими знаками

# функцию max и min можно использовать и для вычисления самой длинной строки передав в аргумент key функцию len
# print(max('aa', 'aaa', key=len))
# print(min('aa', 'aaa', key=len))


# либо даже так, возвращаем ключ максимального значения из словаря:
# from collections import Counter
# print(max(Counter([2,2,1,1,1,2,2]).items(), key=lambda tuple: tuple[1])[0])


# так же max можно использовать для сравнения строк, функция будет взвращать <class 'str'>
# сравнение происходит по номеру каждого символа слево на право по таблице ASCII
# print(max(['111', '444', '333']), type(max(['111', '444', '333'])))
# print(ord('1'), ord('4'), ord('3'))
#
# print(max("a", "б"))

# print(sorted(s)) # возвращает новый отсортированный список в переменную (родительский не трогает)

# print(sorted(s, key=str.lower)) # может принимать в качестве key методы сортируемого объекта в данном случае строки

a = ['ZZZ 800', 'aaa 45', 'eee 43', 'DDD 800', 'BBB 43', 'www 14']
# # сортировка чисел в строке по возврастанию, сортировка букв по алфавиту без учёта регистра
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower())))
# # тоже самое только сортировка чисел по убыванию с помощью -int
# print(sorted(a, key=lambda x: (-int(x.split()[1]), x.split()[0].lower())))
# # тоже самое только сортировка как чисел так и букв по убыванию с помощью аргумента reverse
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower()), reverse=True))

# исключение(фильтрация) элементов последовательности по условию в переданной функции
# print(list(filter(lambda x: x > 4, [1, 2, 3, 4, 5, 6, 7])))

# reduce() применяет функцию к элементам последовательности, сводя ее к единственному значению
# from functools import reduce
# data = {"a": { "b": { "c": { "mykey": "myvalue"}}}}
# print(reduce(dict.get, ["a", "b", "c", "mykey"], data))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4]))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4], 7)) # третий арг. добавится к итоговому результату
#

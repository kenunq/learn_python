# типа данных в питоне

#изменяемые(mutable)
# print(type(   {1,2,"a"}  )) #  -> <class 'set'> множество
# print(type(   {"a":1, 2:"b"}   )) #  -> <class 'dict'> словарь
# print(type(   [1,2,"a"]   )) #  -> <class 'list'> список
#
# from array import array
#
# print(type(  array("l", [1,2,4])  )) #  -> <class 'array.array'> массив
#print(type(bytearray(3))) # -> <class 'bytearray'> массив байт

#неизменяемые (unmutable)
# print(type(   1   )) #  -> <class 'int'> Числа
# print(type(   "abc"   )) #  -> <class 'str'> строки
# print(type(   (1,2,"a")  )) #  -> <class 'tuple'> картеж
# print(type(   None  )) #  -> <class 'NoneType'> Нету данных
# print(type(   False  )) #  -> <class 'bool'> Логическое значение
# print(type(   3.4  )) #  -> <class 'float'> дробное число
# print(type(   2 + 4j  )) #  -> <class 'complex'> комплексное число
# print(type(   frozenset([1,2,"a"])  )) #  -> <class 'frozenset'> Неизменяемое множество
#print(type(   bytes(123)   )) #  -> <class 'bytes'> байты

#print(complex(1+3j)) #создание комплексного числа


#узнать id объекта
# print(id( "str" )) # -> 140735957027056
# print( id( (1,2,"a") ) ) # -> 2850657923840

#узнать адрес в памяти в шестнадцатиричном формате
# print(hex(id("str"))) # -> 0x7fffa4b9c8f0
# print(hex(id(123))) # -> 0x7fffa4cff268

# print("123 = ", bytes(123)) # преобразует объект в неизменяемую строку байтов
# print("Привет Мир! =", bytes('Привет Мир!', encoding='utf-8'))

# перевод int в бинарную строку
# print("123 =", bin(123)) # -> 0b1111011
# print("123 =", bin(123)[2:]) # -> 1111011


#изменяемый обект(id и место в памяти объекта всегда одинаковый)
# x = [1,4,"a"]
# print(id(x), x) # -> 1313106120704 [1, 4, 'a']
# x[1] = 6
# print(id(x), x) # -> 1313106120704 [1, 6, 'a']
# x.append("g")
# print(id(x), x) # -> 1313106120704 [1, 6, 'a', 'g']


#неизменяемый объект(любое действие с объектом меняем его id)
# str = "123"
# print(id(str), str) # -> 2866371710448 123
# str = str[:2] + "6"
# print(id(str), str) # -> 2866371710128 126
# str += "5"
# print(id(str), str) # -> 2866371710320 1265


# Области видимости объектов
#built-in # встроенные функции в интерпретаторе, для их использования не нужно импортировать модули, а так же операторы(зарезервированные слова)
#global #объекты доступные в пространтсве имён модуля
#local # объекты достпуные внутри функции
#nonlocal # объекты доступные из блока внешней функции(обёртки)

# def a():
#     ''' Документация функции a '''
#
# class b:
#     ''' Документация класса b '''
#
#     def my_method_only_my():
#         pass
#
# print("Имя объекта", a.__name__, b.__name__) # позволяет посмотреть имя объекта
# print("Документация объекта", a.__doc__, b.__doc__) # позволяет посмотреть документацию объекта
# print(help(a)) # позволяет посмотреть документацию объекта
# print(globals()) # показывает доступные объекты в пространстве имен модуля
# import math
# print(dir(math)) # позволяет узнать какие объекты содержаться в функции/модуле (без аргументов в текущем пространстве имен модуля)
# print(dir(a))
# print(__name__) # узнать какое состояние имеет переменная __name__ в текущем пространстве имен модуля


# print(callable(len), callable("str")) # проверяем является ли объект вызываемым -> True False

# print(locals()) # возвращает словарь с переменными и их значениями из текущей локальной области видимости в виде словаря(dict)

# проверить, относится ли объект к определенному типу данных

# print(isinstance('str', int)) # -> False
# print(isinstance('str', str)) # -> True
#
# #тоже самое, но с помощью type
#
# print(type('str') == int)
# print(type('str') == str)

#принадлежность объекта к определенному сабклассу можно проверить с помощью функции issubclass

# print(issubclass(int, type(72))) # -> True
# print(issubclass(int, type("Hello, world!"))) # -> False
# print(issubclass(str, type("Hello, world!"))) #-> True

#функция type определяет тип данных

# if type(True) == bool:
#     print("boolean")
# if type(1) == int:
#     print(type(1))

# функция bool преобразует число в True или False
#если число == 0 тогда ложь, если число меньше или больше 0 тогда истина
# print(bool(0))
# print(bool(1))
# print(bool(-1))

# так же и со строками, только вместо 0 принимается пустая строка
# print(bool(""))
# print(bool("123"))

#так же и с коллекциями
# print(bool([]))
# print(bool([1,3]))

#умножение разных типов данных
# print(1 * 5) # int -> 5
# print("1" * 5) # str -> "11111"
# print((1,) * 5) # tuple -> (1, 1, 1, 1, 1)
# print([1] * 5) # list -> [1, 1, 1, 1, 1]
# print([[]] * 5) # list -> [[], [], [], [], []]
# print(["1"] * 5) # list -> ['1', '1', '1', '1', '1']
# print(True*5, 1*5)
# print(False*5, 0*5)

# булевые значения можно сумировать если они сумируются в integer object
#         1     0      1     1
# array = [True, False, True, True]
# count = 0
# for i in array:
#     count += i
# print(count, sum(array)) # -> 3 3


# hash можно найти только у неизменяемых типов данных
# print(hash('str')) # -> 4271691589574039315
# print(hash([1,2,3])) # -> TypeError: unhashable type: 'list'

#код можно писать в 1 строку, с помощью ;
# x = 1; y = 2; z = 3
# print(x,y,z) # -> 1 2 3

# в принт можно добавить sep и пробелы между выводимыми объектами будут заменяться на другие символы
# print(1,2,3, sep='a') # -> 1a2a3

#так же можно задать параметр end тем самым убрать перенос строки
# print(1,2,3, end=" ")
# print(4,5,6) # -> 1 2 3 4 5 6


# читабельный вывод словарей с табуляцией
# import json
# print(json.dump(словарь, indent=4, ensure_ascii=False))

# метод str() переводит int в str
# a = 3
# b = 2.4
# c = 'str' + str(a) + str(b)
# print(c) # -> str32.4

#функция input запрашивает пользователя ввод значения с клавиатуры в консоль
#функция int переводит строковое значение(цифровое) в целое числовое
#функция float переводит строковое значение(цифровое) в число с палвающей точкой
# a = int(input("Введите число")) # <- 5
# b = int("5")
# c = float("2.4") + a + b
# print(c) # -> 12.4


# eval может лишь выполнить выражение python
# print(eval("100 + 101")) # -> 201
# print(eval("sum([10,3,23])")) # -> 36
# print(eval("[i for i in range(5)]")) # -> [0, 1, 2, 3, 4]

x,y = 5,5
# print(eval("x != y")) # -> False
# print(eval("x != y", {"x": 5})) # -> NameError: name 'y' is not defined. Если вторым аргументам в евал передавать словарь, то он будет видеть только переменные из словаря, в словаре можно переоьъявить глобальные пременные

# с помощью compile можно выражение занести в объект
# code = compile("4+5", "<string>", "eval")
# print(eval(code)) # -> 9

# с помощью exec() можно выполнить любой блок когда python
# exec("if 1 > 0: print('Yes 1 > 0')") # -> Yes 1 > 0

#операторы условий
# if
# elif
# else
# :
# pass # заглушка, нужна для того чтобы не писать print() после объявление условий или функции или ``` ```
# ... # работает так же как заглушка
# del # оператор удаление объекта

# логические операторы(имеют приоритет выполнение)
# not # 1
# and # 2
# or # 3

#contiune нужен для того, что бы пропускать итерацию цикла и начинать следующую с самого начала
# break оператор для работы с циклами, нужен для того, чтобы завершать цикл и выходить из тела цикла
# else  оператор для работы с циклами, сработает в том случае если все итерации цикла завершены

# i = 0
# print("==> IN")
# while i < 10:
# 	i += 1
# 	if 3 < i < 6:
# 		print("i=", i, "contiune")
# 		continue
# 	print("i=", i)
# 	if i == 8:
# 		print("i=", i, "break")
# 		break
# else:
# 	print("else worked")
# print("==> OUT")


# Убираем повторяющиеся элементы из списка с помощью цикла
# a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
# b = []
# for i in a:
# 	if not i in b:
# 		b.append(i)
# print(a)
# print(b)
# print(list(set(a))) # аналогичное решение задачи


# сортировка строки по маленьким/большим буквам и не буквенным символам с помощью цикла
# s = 'h@lLo WOrld!'
#
# for i in s:
# 	if "a" <= i <= "z":
# 		print(i, 'small')
# 	elif "A" <= i <= "Z":
# 		print(i, "BIG")
# 	else:
# 		print(i, "not word")


# подсчет повторяющихся символов в строке с помощью цикла
# x = 'frsncsIU$WB$Csfnsdfoisnfcweopfcfsdlfnweocgiroenc'
# result = {}
# for i in x:
# 	try:
# 		result[i] += 1
# 	except:
# 		result[i] = 1
# print(result)

# Операторы сравнений (Проверяют объекты на равенство их значений)
# ==
# <
# >
# <=
# >=
# !=

# построение диапазона значений

# x = 4
# if 2 <= x <= 10:
# 	print("х в диапазоне от 2 до 10")

# опеароты сравнений можно записать в цеопчкке
# x,y,z = 1,1,1
#
# if x == y == z:
# 	print("все числа равны")

# оператор in если объект совпадает хотя бы частично с другим объектов тогда выдает True
# x = "abc"
# y = "adcs"
# z = "abcd"
# print(x in z) # -> True
# print(y in z) # -> False

# оператор is если объекты ссылаются на одну и ту же ячейку памяти, тогда True
# x = 10
# y = int("10")
# print(x is y) # -> True


# для слишком больших чисел выделяется отдельная область в памяти
x = 31**25
y = 31**25
print(x, x is y) # True
a = 26**26
b = 26**26
print(a, a is b) # False
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

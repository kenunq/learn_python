# типа данных в питоне

#изменяемые(mutable)
# print(type(   {1,2,"a"}  )) #  -> <class 'set'> множество
# print(type(   {"a":1, 2:"b"}   )) #  -> <class 'dict'> словарь
# print(type(   [1,2,"a"]   )) #  -> <class 'list'> список
#
# from array import array
#
# print(type(  array("l", [1,2,4])  )) #  -> <class 'array.array'> массив
#print(type(bytearray(3))) # -> <class 'bytearray'> массив байт

#неизменяемые (unmutable)
# print(type(   1   )) #  -> <class 'int'> Числа
# print(type(   "abc"   )) #  -> <class 'str'> строки
# print(type(   (1,2,"a")  )) #  -> <class 'tuple'> картеж
# print(type(   None  )) #  -> <class 'NoneType'> Нету данных
# print(type(   False  )) #  -> <class 'bool'> Логическое значение
# print(type(   3.4  )) #  -> <class 'float'> дробное число
# print(type(   2 + 4j  )) #  -> <class 'complex'> комплексное число
# print(type(   frozenset([1,2,"a"])  )) #  -> <class 'frozenset'> Неизменяемое множество
#print(type(   bytes(123)   )) #  -> <class 'bytes'> байты

#print(complex(1+3j)) #создание комплексного числа


#узнать id объекта
# print(id( "str" )) # -> 140735957027056
# print( id( (1,2,"a") ) ) # -> 2850657923840

#узнать адрес в памяти в шестнадцатиричном формате
# print(hex(id("str"))) # -> 0x7fffa4b9c8f0
# print(hex(id(123))) # -> 0x7fffa4cff268

# print("123 = ", bytes(123)) # преобразует объект в неизменяемую строку байтов
# print("Привет Мир! =", bytes('Привет Мир!', encoding='utf-8'))

# перевод int в бинарную строку
# print("123 =", bin(123)) # -> 0b1111011
# print("123 =", bin(123)[2:]) # -> 1111011


#изменяемый обект(id и место в памяти объекта всегда одинаковый)
# x = [1,4,"a"]
# print(id(x), x) # -> 1313106120704 [1, 4, 'a']
# x[1] = 6
# print(id(x), x) # -> 1313106120704 [1, 6, 'a']
# x.append("g")
# print(id(x), x) # -> 1313106120704 [1, 6, 'a', 'g']


#неизменяемый объект(любое действие с объектом меняем его id)
# str = "123"
# print(id(str), str) # -> 2866371710448 123
# str = str[:2] + "6"
# print(id(str), str) # -> 2866371710128 126
# str += "5"
# print(id(str), str) # -> 2866371710320 1265


# Области видимости объектов
#built-in # встроенные функции в интерпретаторе, для их использования не нужно импортировать модули, а так же операторы(зарезервированные слова)
#global #объекты доступные в пространтсве имён модуля
#local # объекты достпуные внутри функции
#nonlocal # объекты доступные из блока внешней функции(обёртки)

# def a():
#     ''' Документация функции a '''
#
# class b:
#     ''' Документация класса b '''
#
#     def my_method_only_my():
#         pass
#
# print("Имя объекта", a.__name__, b.__name__) # позволяет посмотреть имя объекта
# print("Документация объекта", a.__doc__, b.__doc__) # позволяет посмотреть документацию объекта
# print(help(a)) # позволяет посмотреть документацию объекта
# print(globals()) # показывает доступные объекты в пространстве имен модуля
# import math
# print(dir(math)) # позволяет узнать какие объекты содержаться в функции/модуле (без аргументов в текущем пространстве имен модуля)
# print(dir(a))
# print(__name__) # узнать какое состояние имеет переменная __name__ в текущем пространстве имен модуля


# print(callable(len), callable("str")) # проверяем является ли объект вызываемым -> True False

# print(locals()) # возвращает словарь с переменными и их значениями из текущей локальной области видимости в виде словаря(dict)

# проверить, относится ли объект к определенному типу данных

# print(isinstance('str', int)) # -> False
# print(isinstance('str', str)) # -> True
#
# #тоже самое, но с помощью type
#
# print(type('str') == int)
# print(type('str') == str)

#принадлежность объекта к определенному сабклассу можно проверить с помощью функции issubclass

# print(issubclass(int, type(72))) # -> True
# print(issubclass(int, type("Hello, world!"))) # -> False
# print(issubclass(str, type("Hello, world!"))) #-> True

#функция type определяет тип данных

# if type(True) == bool:
#     print("boolean")
# if type(1) == int:
#     print(type(1))

# функция bool преобразует число в True или False
#если число == 0 тогда ложь, если число меньше или больше 0 тогда истина
# print(bool(0))
# print(bool(1))
# print(bool(-1))

# так же и со строками, только вместо 0 принимается пустая строка
# print(bool(""))
# print(bool("123"))

#так же и с коллекциями
# print(bool([]))
# print(bool([1,3]))

#умножение разных типов данных
# print(1 * 5) # int -> 5
# print("1" * 5) # str -> "11111"
# print((1,) * 5) # tuple -> (1, 1, 1, 1, 1)
# print([1] * 5) # list -> [1, 1, 1, 1, 1]
# print([[]] * 5) # list -> [[], [], [], [], []]
# print(["1"] * 5) # list -> ['1', '1', '1', '1', '1']
# print(True*5, 1*5)
# print(False*5, 0*5)

# булевые значения можно сумировать если они сумируются в integer object
#         1     0      1     1
# array = [True, False, True, True]
# count = 0
# for i in array:
#     count += i
# print(count, sum(array)) # -> 3 3


# hash можно найти только у неизменяемых типов данных
# print(hash('str')) # -> 4271691589574039315
# print(hash([1,2,3])) # -> TypeError: unhashable type: 'list'

#код можно писать в 1 строку, с помощью ;
# x = 1; y = 2; z = 3
# print(x,y,z) # -> 1 2 3

# в принт можно добавить sep и пробелы между выводимыми объектами будут заменяться на другие символы
# print(1,2,3, sep='a') # -> 1a2a3

#так же можно задать параметр end тем самым убрать перенос строки
# print(1,2,3, end=" ")
# print(4,5,6) # -> 1 2 3 4 5 6


# читабельный вывод словарей с табуляцией
# import json
# print(json.dump(словарь, indent=4, ensure_ascii=False))

# метод str() переводит int в str
# a = 3
# b = 2.4
# c = 'str' + str(a) + str(b)
# print(c) # -> str32.4

#функция input запрашивает пользователя ввод значения с клавиатуры в консоль
#функция int переводит строковое значение(цифровое) в целое числовое
#функция float переводит строковое значение(цифровое) в число с палвающей точкой
# a = int(input("Введите число")) # <- 5
# b = int("5")
# c = float("2.4") + a + b
# print(c) # -> 12.4


# eval может лишь выполнить выражение python
# print(eval("100 + 101")) # -> 201
# print(eval("sum([10,3,23])")) # -> 36
# print(eval("[i for i in range(5)]")) # -> [0, 1, 2, 3, 4]

x,y = 5,5
# print(eval("x != y")) # -> False
# print(eval("x != y", {"x": 5})) # -> NameError: name 'y' is not defined. Если вторым аргументам в евал передавать словарь, то он будет видеть только переменные из словаря, в словаре можно переоьъявить глобальные пременные

# с помощью compile можно выражение занести в объект
# code = compile("4+5", "<string>", "eval")
# print(eval(code)) # -> 9

# с помощью exec() можно выполнить любой блок когда python
# exec("if 1 > 0: print('Yes 1 > 0')") # -> Yes 1 > 0

#операторы условий
# if
# elif
# else
# :
# pass # заглушка, нужна для того чтобы не писать print() после объявление условий или функции или ``` ```
# ... # работает так же как заглушка
# del # оператор удаление объекта

# логические операторы(имеют приоритет выполнение)
# not # 1
# and # 2
# or # 3

#contiune нужен для того, что бы пропускать итерацию цикла и начинать следующую с самого начала
# break оператор для работы с циклами, нужен для того, чтобы завершать цикл и выходить из тела цикла
# else  оператор для работы с циклами, сработает в том случае если все итерации цикла завершены

# i = 0
# print("==> IN")
# while i < 10:
# 	i += 1
# 	if 3 < i < 6:
# 		print("i=", i, "contiune")
# 		continue
# 	print("i=", i)
# 	if i == 8:
# 		print("i=", i, "break")
# 		break
# else:
# 	print("else worked")
# print("==> OUT")


# Убираем повторяющиеся элементы из списка с помощью цикла
# a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
# b = []
# for i in a:
# 	if not i in b:
# 		b.append(i)
# print(a)
# print(b)
# print(list(set(a))) # аналогичное решение задачи


# сортировка строки по маленьким/большим буквам и не буквенным символам с помощью цикла
# s = 'h@lLo WOrld!'
#
# for i in s:
# 	if "a" <= i <= "z":
# 		print(i, 'small')
# 	elif "A" <= i <= "Z":
# 		print(i, "BIG")
# 	else:
# 		print(i, "not word")


# подсчет повторяющихся символов в строке с помощью цикла
# x = 'frsncsIU$WB$Csfnsdfoisnfcweopfcfsdlfnweocgiroenc'
# result = {}
# for i in x:
# 	try:
# 		result[i] += 1
# 	except:
# 		result[i] = 1
# print(result)

# Операторы сравнений (Проверяют объекты на равенство их значений)
# ==
# <
# >
# <=
# >=
# !=

# построение диапазона значений

# x = 4
# if 2 <= x <= 10:
# 	print("х в диапазоне от 2 до 10")

# опеароты сравнений можно записать в цеопчкке
# x,y,z = 1,1,1
#
# if x == y == z:
# 	print("все числа равны")

# оператор in если объект совпадает хотя бы частично с другим объектов тогда выдает True
# x = "abc"
# y = "adcs"
# z = "abcd"
# print(x in z) # -> True
# print(y in z) # -> False

# оператор is если объекты ссылаются на одну и ту же ячейку памяти, тогда True
# x = 10
# y = int("10")
# print(x is y) # -> True


# для слишком больших чисел выделяется отдельная область в памяти
# x = 31**25
# y = 31**25
# print(x, x is y) # True
# a = 26**26
# b = 26**26
# print(a, a is b) # False


#для списков выделяется отдельная область в памяти
# x = [1,2,3]
# y = [1,2,3]
# z = x
# print(x is y) # -> False
# print(x is z) # -> True
# print(y is z) # -> False

# самое большое число в питоне float('inf'), он действует как неограниченное верхнее значение
# print(float('inf') > 99999999999**999999) # -> True


# Математические операторы (имеют приоритет выполнения)
# a = 10 + 5
# a = 10 - 5
# a = 10 * 5
# a = 19 / 5 # обычное деление, ответ = 3.8
# a = 19 // 5 # деление с отбросом остатка после точки (в числе 19 число 5 помещается 3 раза)
# Остаток от деления 19 % 7 в число 19 число семь помещается 2 раза, остаток = 5

#найти числа кратные 4
# for i in range(50):
#     if i % 4 == 0:
#         print(i)


#операции с числами

#функция sum() сумирует все числа в списке
# print(sum([1,2,3,4,5])) # -> 15

#функция abs() переводит число из отрицательного в положительное
# print(abs(-12)) # -> 12

#функция min() находит наименьшее число из списка
# print(min([2,4,6,2,1,0,-2,-54,-1])) # -> -54

#функция max() находит наибольшее число из списка
# print(max([2,4,6,2,1,0,-2,-54,-1])) # -> 6

#функция pow() возводит число в степень
# print(pow(5,5), 5**5) # -> 3125 3125

#функция round() округляет число в плавающей точкой в большую или меньшую сторону в зависимости куда ближе, так же можно вторым аргументом передать, сколько оставить цифр после запятой
# (round(5.6342)) # -> 6
# print(round(5.27234, 1)) # -> 5.3

import math
#функция math.ceil окргуляет число всегда в большую сторону
# print(math.ceil(5.3)) # -> 6

#функция math.floor окргуляет число всегда в меньшую сторону
# print(math.floor(5.9)) # -> 5

#функция math.trunc убирает цифры после точки, работает аналогично int()
# print(math.trunc(5.7)) # -> 5

#math.pi - число pi
# print(math.pi) # -> 3.141592653589793

#разделение числа по цифрам c помощью математических операторов
# x=3456
#
# n1 = x // 1000
# n2 = x // 100 % 10
# n3 = x // 10 % 10
# n4 = x % 10
# print(n1, n2 ,n3 ,n4)

#программа открывающая сайт
# import os
# while True:
#     sait = input()
#     if "https://" in sait:
#         os.system("start " + sait)
#         break

#модуль рандом
# import random
# for i in range(20):
#     print(random.randrange(1, 100))

# while оператор цикла исполняется (пока условие верно)
# цикл от 1 до 5
# можно подключить оператор else который сработает по завершению цикла
# a = 0
# while a < 5 :
# 	a += 1
# 	print(a)
# else :
# 	print("finish")

#цикл for
# x = [1,2,3,4,5,6]
# for i in x[3:]:
#     print(i) # -> 4 5 6

# итерация элементов в итерируемом объекте с помощью функций iter() next()
# x = range(5)
# print(x, type(x)) # -> range(0, 5) <class 'range'>
#
# it = iter(x)
# it = x.__iter__() # тоже самое - другая запись
# print(it, type(it))
#
# n1 = next(it)
# n2 = it.__next__()
# n3 = next(it)
# n4 = next(it)
# n5 = next(it)
# print(n1,n2,n3,n4,n5) # -> 0 1 2 3 4

# если элементы закончились и еще раз прописать next() то выйдет исключение StopIteration


# функция zip() упаковывает элементы из 2-х списков в кортеж, [ (a[0], b[0]) , (a[1], b[1]) ]
# a = [5,6,7]
# b = [100,200,300, 400]
#
# zp = zip(a,b)
# print(zp,type(zp), list(zp)) # -> <zip object at 0x000001A662F94D40> <class 'zip'> [(5, 100), (6, 200), (7, 300)]


#########################################################################################
# Список (list) упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#########################################################################################

# индексация с конца            -4              -3                -2               -1
# индексация с начала            0               1                 2                3
# x = [1,2,3,'abc', [123,123,321], (1,3,5)]
#
# #узнать длины списка можно с помощью функции len()
# print(x[0], len(x)) # -> 1 6
#
# #без исключения обратиться к последнему элементу списка(если он пустой)
# # lst = []
# # x = lst[-1:] or None
# # print(x)
#
# #можно обращаться ко вложенным списка
# print(x[4][0]) # -> 123
#
# #можно перезаписывать определенную ячейку списка
# x[0] = 5
# print(x)
#
# #можно менять переменные местами множественным присваиванием
# x[0], x[2] = x[2], x[0]
# print(x)
#
# #можно добавить данные в список
# x = x + [[1,2,3]]
# print(x)

#функция list() разбивает строку по 1-му символу в лист
# x = list("abcdfsdf")
# print(x)

# сравнение списков (при этом происходит поочередное сравнение каждого элемента списка слева на право)
# print('[1] <= [1]', [1] <= [1]) # -> True
# print('[2] <= [1]', [2] <= [1]) # -> False
# print('[1, 1] <= [1, 1]', [1, 1] <= [1, 1]) # -> True
# print('[1, 2] <= [1, 1]', [1, 2] <= [1, 1]) # -> False

#методы для работы со списками

# x = [1,2,3,4,5]
# #узнаем есть ли значение в промежутке списка от 1 до 4
# print(3 in x[1:4]) # -> True
#
# #узнать длины списка можно с помощью функции len()
# print(len(x)) # -> 5
#
# # .append() добавляет элемент в конец списка
# # x.append("qwe")
# # print(x) # -> [1, 2, 3, 4, 5, 'qwe']
#
# # .insert() вставляет элемент в указанный индекс
# # x.insert(0, "5")
# # print(x) # -> ['5', 1, 2, 3, 4, 5, 'qwe']
#
# # .count() подсчитывает сколько одинаковых элементов в списке по значению
# print(x.count(5)) # -> 1
#
# # .index() узнаем индекс элемента по его имени
# print(x.index(5)) # -> 5 (2 arg = с какого индекса начать поиск 3arg = до какого индекса искать)
#
# # .sort() сортирует список по возрастанию, если добавить reverse=True список отсортируется по убыванию
# # так же есть 2 аргумент key=func, чтобы менять принцип сортировки
# x.sort(reverse=True)
# print(x) # -> [5, 4, 3, 2, 1]
# c = sorted(x, key=abs) # возвращает новый отсортированый список, не трогая родительский
# print(c) # -> [1, 2, 3, 4, 5]
#
# # .reverse() инвертирует список и перезаписывает его в ту же ячейку памяти
# print("1:", x)
# x.reverse()
# print("2:", x)
#
# #reversed() создает итератор с инвертированными элементами
# # (аналогично x = list('98765') x.reverse() print(x))
# print(reversed("74452"))
#
# # .pop удаляет элемент по указанному индексу (если указать переменную, то сохранит удаленный элемент в переменную)(без аргументов удаляет элемент в конце списка)
# xd = x.pop(0)
# print(x, xd) # -> [2, 3, 4, 5] 1
#
# # .remove() удаляет элемент по его имени
# x.remove(2)
# print(x) # -> [3, 4, 5]
#
# # .clear() полностью очищает список
# x.clear()
# print(x) # -> []
#
# # .extend() распаковывает список в конец списка
# x.extend(["123", 'wp', 123])
# print(x) # -> ['123', 'wp', 123]
#
# # .copy() копирует список в переменную
# xc = x.copy()
# print(xc) # -> ['123', 'wp', 123]
# #analog
# xc1 = x[:]
# xc2 = list(x)
# print(xc1, xc2) # -> ['123', 'wp', 123] ['123', 'wp', 123]
#
# #списки можно складывать
# x = ['Hello']+['world']+['!']
# print(x) # -> ['Hello', 'world', '!']
#
# #переводим список обратно в строку
# text = '_'.join(x)
# print(text) # -> Hello_world_!

# a = list(range(10))
# b = []
# for i in a:
#     if i == (5 or 6):
#         continue
#     b.append(i)
# else:
#     print(b)
#
# # в списках можно использовать срезы, также как и в строках
#
# #если нам нужно скопировать список, то используем метод copy()
# c = a.copy()
# #либо более точное средство(синтаксис срезов)[start:stop:step]
# c = a[::] # -> [0, 1, 2, 3, 4, 6, 7, 8, 9]
# #заменяем цикл одной строчкой
# c = a[0::2] # получаем только нечетные индексы # -> [0,2,4,6,8]
# c = a[1::2] # получаем только четные индексы # -> [1,3,5,7,9]
# c = a[:5] # получаем список до 5 индекса включительно # -> [0,1,2,3,4]
#
# # заменяем первые 2 элемента на значения из нового списка
# c[:2] = ["a", "b"] # -> ['a', 'b', 2, 3, 4]
#
# # удалить значение по индексы
# del c[2] # -> ['a', 'b', 3, 4]
# print(c)
#
# # удаляем из списка все четне числа и заносим их в новый список
#
# for i in a:
#     if i % 2 == 0:
#         a.remove(i)
#         b.append(i)
# else:
#     print(a, b)


#######################################################################################################
# Кортеж (tuple) неизменяемая упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#######################################################################################################

# создание кортежа без помощи круглых скобок с одним значением и запятой
# x = 1,
# print(x, type(x))

#создание кортежа, скобки дают наглядное представление, что это кортеж
# x = (1,2,3)
# print(x)
#присвоение значений из кортежа в переменные
# a,b,c = x
# print(a,b,c)

# создание пустого кортежа
# x = ()
# print(x)
# x = tuple() # аналог
# print(x)

#для создание кортежа можно использовать любую итерабельную последовательность
# print(tuple([1,2,3]), tuple({"a":1, "b":2}), tuple({1,2,3}), tuple((1,2,3)), tuple("123"), tuple(range(3))) # -> (1, 2, 3) ('a', 'b') (1, 2, 3) (1, 2, 3) ('1', '2', '3') (0, 1, 2)

#кортеж имеет индексацию по аналогии со списками
# x = tuple(range(4))
# print(x[2])


#хоть кортеж и является не изменным, но если в нем содержится изменяемый тип данных, то мы можем изменить его
# x = (1,2,[1,2])
# x[2].append(2)
# print(x) # -> (1, 2, [1, 2, 2])

#кортеж можно использовать в качестве ключа для словаря
# x = 1,2,3
# b = {}
# b[x] = 123
# print(b) # -> {(1, 2, 3): 123}

#у кортежа очень мало методов, поэтому можно преобразовать его в список - изменить - преобразовать обратно
# x = (1,2,3,4,5,6)
# x1 = list(x)
# x1[0] = -1
# x1.append(7)
# x2 = tuple(x1)
# print(x2) # -> (-1, 2, 3, 4, 5, 6, 7)

#обращение к элементу кортежа по индексу
# x = ("i", "love", "u")
# print(x[1]) # -> love

#к кортежу можно применять срез
# x = (1,2,3,4,5,6)
# # print(x[1:3]) # -> (2, 3)

#кортежи можно складывать
# x = (1,2)
# x1 = (3,4,5,6)
# print(x + x1) # -> (1, 2, 3, 4, 5, 6)

#кортежи можно умножать
# x = (1,2,3)
# print(x * 2) # -> (1, 2, 3, 1, 2, 3)

#с помощью in можно проверить находится ли объект в кортеже
# x = ('a', 'b', 'c')
# print( 'a' in x , 'n' in x ) # -> True False

#функция enuerate превращает каждый элемент в кортеж, состоязий из индекса и значение
#может принимать 2арг, в котором указывается, с какого индекса начинать
# print(list(enumerate([1,2,3,4,5], 111))) # -> [(111, 1), (112, 2), (113, 3), (114, 4), (115, 5)]

# dct = {"111": 10, "112": 11}
# for index, value in enumerate(dct):
#     print(index, value) # -> 0 111, 1 112

#########################################
# Методы для работы с кортежами (tuple) #
#########################################
# x = (1,2,3,4,5)
#
# print(len(x)) # -> 5
# print(x.count(1)) # -> 1
# print(x.index(4)) # -> 3
# print(sorted(x, reverse=True)) # -> [5,4,3,2,1]

################################### Блок Кортежа закончен ###################################

######################
# Работа с функциями #
######################

#функция определения каллорийности

# def calorie_calculate(name, get_calorie, spend_calorie):
#     if get_calorie > spend_calorie:
#         msg = name + " getting fat"
#     else:
#         msg = name + " lose weight"
#     return msg

# print(calorie_calculate("Ivan", 1200, 1300)) # -> Ivan lose weight
# persone = ["Slava", 1300, 1200]
# #в функцию можно передавать список со значениями, указав * перед списком
# print(calorie_calculate(*persone)) # -> Slava getting fat


#return возвращает значени в точку запуска функции name_func()
#
# def qwe():
#     x = 2 + z
#     return x
#
# z = 3
# #переменные должны объявляться выше вызываемой функции связанной с этими переменными
# y = qwe()
# print(y) # -> 5
# #взаимодейстовать с переменной x можно только через return
# y = qwe() + 1
# print(y) # -> 6

# в функцие можно указывать дефолтные аргументы и давать им значения
# def count_list(list, boolean = False, count = 0):
#     if boolean == True:
#         typelist = type(list[5]) # узнаем тип элемента списка
#         for i in list:
#            count += 1 #узнаем сколько элементов в списке
#         return count, typelist
#     else:
#         for i in list:
#             count += 1
#         return count
#
# j = [9, 8, 7, 6, "a", 0.4, True]
# h,p = count_list(j, True)
# print(h,p) # -> 7 <class 'float'>

# если нужно распокавать больше значений чем переменных, тогда остальные значение попадут в переменную-лист со *
# *x, y, z = 2, 3
# # print(x,y,z) # -> [] 2 3
# #
# # x, *y, z = 2,3
# # print(x,y,z) # -> 2 [] 3
# #
# # x,y, *z = 2,3
# # print(x,y,z) # -> 2 3 []
# #
# # *x, y, z = 1 ,2,3,4,5,6,7,8
# # print(x,y,z) # -> [1, 2, 3, 4, 5, 6] 7 8

#если перед аргументом поставить * то все аргумента после него превратяться в кортеж, можно записать аргументы после кортежа, если указать в вызове имя аргумента и значение

# def name(h,d, *args, key1, key2):
#     print(h) # -> 1
#     print(d) # -> 2
#     print(args) # -> (3,4,5)
#     print(key1) # -> 6
#     print(key2) # -> 7
#
# name(1,2,3,4,5,key1=6, key2=7)

#функция возвращает по 1 элементы без повторений
# def exclusive_item(*args, key=True):
#     newlist = []
#     for i in args:
#         for y in i:
#             if y not in newlist:
#                 newlist.append(y)
#     if key:
#         newlist.sort()
#     return newlist
#
# print(exclusive_item([3,1,5,7,2,4,2])) # -> [1, 2, 3, 4, 5, 7]


#args=arguments
# def print_ab(a,b, *args):
#     print(a)
#     print(b)
#     print(args)
#
# #передача списка спомощью спец. символа * разбивает его поэлементно и отправляет каждый элемент в виде отдельного аргумента
# x = [1,2,3,4,5,6,7]
# print_ab(*x) 1 2 (3, 4, 5, 6, 7)
# # Если не угадать с количеством передаваемых элементов и объявленых аргументов в функции
# # то получим исключение TypeError, что бы не прописывать каждый аргумент в функции, можно
# # воспользоваться спец символом * уже в функции для включения всех полученных элементов в один кортеж

#kwargs = keyword arguments
# # если между позиционными a, b и запакованными **kwargs стоит слеш то аргументы из **kwargs автоматически не перейдут в a, b
# def print_ab2(a, b, /,**kwargs):
#     print(a)
#     print(b)
#     print(kwargs)
#
# #таким же способ можно передавать с помощью * ключи словаря, а с помощью ** значения словаря
# dct = {'a':10, 'b':20, 'c':30, 'd':40}
# print_ab2(**dct)
# print_ab2(1, 2, c=10, d=20)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#перезаписываем элементы которые объявлены вне функции с помощью global
# x = 5
# def qwe():
#     global x
#     x = 10
# print(x) # -> 5
# qwe()
# print(x) # -> 10

#аналог global но можно использовать только во вложенной функции nonlocal

# x = 5
# def qwe():
#     x=10
#     print(x) # -> 10
#     def qwe1():
#         nonlocal x
#         x = 15
#         print(x) # -> 15
#     qwe1()
#     print(x) # -> 15
# print(x) # -> 5
# qwe()
# print(x) # -> 5

# #Вычисляем объем цилиндра
# import math
# #Контсанты принято записывать в верхнем регистре
# PI = math.pi
#
# def get_radius():
#     return float(input("Введите Радиус цилиндра"))
#
# def get_height():
#     return float(input("Введите высоту цилиндра"))
#
# def get_v():
#     r = get_radius()
#     h = get_height()
#     s = PI * r ** 2
#     v = s * h
#     return v
#
# print("Объем цилиндра:", get_v(), "см3")



##################################################################################################
# Словарь (dict) изменяемая неупорядоченная коллекция произвольных элементов с доступом по ключу #
# иногда ещё называют ассоциативным списком или хеш-таблицей.                                   #
# в словаре данные всегда привязаны к ключу                                                      #
#                                                                                                #
# ключём в словаре могут быть только неизменяемые типы данных,                                   #
# если в кортеже содержится изменяемый тип данных то кортеж не может быть ключём.                #
##################################################################################################



# d = {}
# tpl = ((1, 2, (1, 2, [1, 2])), 1, 2)
# # для ключа словаря можно использовать только полностью не изменяемые типы данных
# # даже глубоко вложенный изменяемый тип данных - список - вызовет ошибку: TypeError: unhashable type: 'list'
# d[tpl] = 'test'

# dict1 = {}
# not_mutable_tuple = (1,2,(1,3))
# dict1[not_mutable_tuple] = "text"
# print(dict1)

# #Создаем пустой словарь
# dict1 = {}
# #с помощью функции
# dict2 = dict()
# print(dict2)

# d1 = {"name": "Ivan", "lang": "ru"}
# print(d1) # -> {'name': 'Ivan', 'lang': 'ru'}
# d2 = dict(name="Ivan", lang="ru")
# print(d2) # -> {'name': 'Ivan', 'lang': 'ru'}




# #Вызов по ключу
# d = {"a": 5}
# print(d["a"]) # -> 5
# #Добавление новое ключ-значение в словарь
# d["b"] = 6
# print(d) # -> {'a': 5, 'b': 6}
# #Изменение существующего значение через ключ
# d["a"] = 3
# print(d) # -> {'a': 3, 'b': 6}
# #Удаление элемента по ключу
# del d["a"]
# print(d) # -> {'b': 6}

# print(dict(odin=1, dva=2)) # -> {'odin': 1, 'dva': 2}
# print(dict([["odin",1], ["dva", 2]])) # -> {'odin': 1, 'dva': 2}


# Заменяем ключ в словаре
# new_dict = { str(k).replace(str('какой_то_ключ'), 'заменяем_на_этот_ключ'): v for k, v in old_dict.items() }


#при сравнении словарей сравниваются как ключи так и их значения
# d1 = {'a':4, 'b':4}
# d2 = {'a':4, 'b':4}
# d3 = {'a':4, 'b':3}
# print(d1 == d2, d1 == d3) # -> True False

# сравнить только ключи
# print(d1.keys() == d2.keys(), d1.keys() == d3.keys())

#узнаем ключ по значению
# d = {"a": 12, "b": 33, "c": 123, "d": 1}
# print(list(d.keys())[list(d.values()).index(12)])

#########################################
# Методы для работы со словарями (dict) #
#########################################

d1 = {1:'one', 2:'two', 3:'three', 4:'four'}

# print(dict.fromkeys([1,2,3,4,5], "qwe")) # -> {1: 'qwe', 2: 'qwe', 3: 'qwe', 4: 'qwe', 5: 'qwe'}
#
# d1.clear() # - очищает полностью словарь
# print(d1) # -> {}

#get выводит значение по ключу, как и вызов через квадратные скобки, но если значения не будет, то выдаст none
# print(d1.get(3)) # ->  three

#2 аргумент будет заменять none на 2арг
# print(d1.get(7, "netu")) # -> netu

# setdefault Возвращает значение выбранного ключа, если такого ключа нету создаёт ключ со значением None и так же возвращает None.
# Если указать через запятую своё значение то оно запишеться вместо None и оно же вернётся

# print(d1.setdefault(11, "qwe")) # -> qwe
# print(d1) # -> {1: 'one', 2: 'two', 3: 'three', 4: 'four', 11: 'qwe'}

# print(d1.pop(3)) # удаляет пару ключ:значение и возвращает значение удалённой пары, является аналогом del словарь[ключ]
# print(d1.popitem()) # удаляет случайную пару и возвращает ключ:значение удалённой пары


#dict.items() возвращает список с кортежами ключ:значение, нужно для работы с циклом фор
# print(d1.items()) # -> dict_items([(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')])
#
# print(d1.keys()) # возвращает ключи в виде списка (нужен для работы с циклом for) может использоваться как множество, т.к. ключи уникальны
# print(d1.values()) # возващает значения в виде списка (нужен для работы с циклом for)

# new_d = {2:'перезаписали значение двойки', 'профессия':'программист'}
# print(d1) # -> {1: 'one', 2: 'two', 3: 'three', 4: 'four'}
# d1.update(new_d) # добавить пары ключ:значение из одного словаря в другой, если ключи уже существуют их значения будут перезаписаны
# print(d1) # -> {1: 'one', 2: 'перезаписали значение двойки', 3: 'three', 4: 'four', 'профессия': 'программист'}

# a = d1.copy() # создаёт копию словаря в новой переменной
# print(len(d1)) # узнать количество пар в словаре
# print(2 in d1) # узнать есть ли такой ключ в словаре

# print(sorted(d1, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)


# Контекстный менеджер with автоматически закрывает файл после работы с ним
# with open('C:\\Users\\pokam\\Desktop\\Новый текстовый документ (15).txt', 'r') as file:
#     text = file.read()
#     print(text)


# text = file.read() # прочитать весь файл целиком
# text = file.readline() # прочитать файл построчно
# text = file.readlines() # прочитать файл построчно и передать данные в переменную в виде списка
# text = file.write('строка текста') # записать в файл строку текста
# print(text)
# file.close() # закрыть файл

# 'r' Открыть для чтения (по умолчанию если не указывать параметр)
# 'w' Открыть для записи, содержимое файла удаляется, если файла нет, создаётся новый
# 'x' Открытие на запись, если файла не существует, иначе исключение.
# 'a' Открыть для дозаписи в конец файла, если файла нет, создаётся новый
# 't' Открыть в текстовом режиме (по умолчанию если не указывать параметр)
# 'b' Открыть в бинарном режиме (двоичном) 'rb', 'wb', 'ab'
# '+' Открыть для чтения и записи 'r+', 'w+', 'a+'


# запись текста в файл
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt', 'w')
# print(file)
# # file.write('текста строка')
# file.close()

# чтение текста из файла
# file = open('C:\\pyTraining\Тест папка\Новый текстовый документ 1.txt')
# text = file.read()
# # text = file.read(5) # если указать число в функции read() можно прочитать определенное количество символов
# # text = file.seek(0) # указав число в функции seek() мы переместимся на чтение с указанного номера символа
# print(text)
# file.close()



#######################################################################################################
# Множество (set) неупорядоченная коллекция уникальных элементов (отсутствуют повторяющиеся значения) #
# может состоять только из неизменяемых типов данных: число, строка, кортеж                           #
#######################################################################################################

#создать set можно с помощью {} скобок
# a = {1,2,2,2,4,5,6,3,4,5,6,6} # выглядит как дикт, но если указывая значения через запятую, то будет множество
# print(a, type(a)) # -> {1, 2, 3, 4, 5, 6} <class 'set'>
#так же можно создать с помощью set()
# a = set()
# print(a, type(a)) # -> set() <class 'set'>

# преобразуем список с повторяющимися значениями в множество затем обратно в список, тем самым убирая повторяющиеся значения
# print(list(set([1, 1, 2, 2, 3, 3, 4, 4, 5, 5])))


# x_tuple = (1, 2, 3, 4, 5, 6, 7)
# x_list = [1, 2, 3, 4, 5, 6, 7]
# x_dict = {'1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7}
# x_set = {1, 2, 3, 4, 5, 6, 7} # множества работают гораздо быстрее чем остальные типы списков
# # размер списка в памяти
# print(x_tuple.__sizeof__()) # 80
# print(x_list.__sizeof__()) # 96
# print(x_dict.__sizeof__()) # 344
# print(x_set.__sizeof__(), '\n') # 712
# from sys import getsizeof
# print(getsizeof(x_tuple)) # 80
# print(getsizeof(x_list)) # 96
# print(getsizeof(x_dict)) # 344
# print(getsizeof(x_set)) # 712


##########################################
# Методы для работы со множествами (set) #
##########################################

# z = {1, 2, 3, 4, 5}
# x = {3, 4, 5, 6, 7}
#
# # при добавлении или объединении значения которые повторяются не будут дублироваться
# z.add(6)
# print(z)
# z.update([7, 8]) # добавить значения из итерабильного объекта в множество
# z.update((9, 10))
# z.update({11, 12})
# z.update('ABCD') # добавляет в рандомном порядке
# print(z)

# y = z.union(x) # объединить множества # аналог y = z | x
# print(y) # -> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'D', 'B', 'A'}
# z = z.union(x) # перезаписать объединённые множества в z # аналог z |= x
# print(z) # -> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'D', 'B', 'A'}

# z.discard(4) # удалить один элемент из множества (ничего не делает если такого элемента нет)
# print(z) # -> {1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'D', 'B', 'A'}

# z.remove(6) # удалить один элемент из множества (дропает исключение KeyError если такого элемента нет)
# print(z)

# z.pop() # удалить первый элемент из множества,
# print(z) # -> {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'C', 'B', 'D', 'A'}

# y = z.intersection(x) # получить повторяющиеся элементы в двух множествах # аналог y = z & x
# print(y) # -> {3, 4, 5, 6, 7}

# z.intersection_update(x) # перезаписать в z пересечение значений # аналог z &= x
# print(z) # -> {3, 4, 5, 6, 7}

# y = z.difference(x) # получить не повторяющиеся элементы из первого множества
# print(y) # -> {1, 2, 'B', 'C', 8, 9, 10, 11, 12, 'D', 'A'}

# z.difference_update(x) # перезаписать в z не повторяющиеся элементы из первого множества # аналог ^=

# print(z ^ x) # получить не повторяющиеся элементы из первого и второго множества одновременно

# print(z - x) # вычесть значения одного множества из значений другого множества

# z.issubset(x) # или  z <= x  все элементы z принадлежат x.
# z.issuperset(x) # или  z >= x  аналогично.
# z.isdisjoint(x) # истина, если z и x не имеют общих элементов.

# print(sorted(z, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)


###############################################################################################
# Строка (str) упорядоченная последовательность символов (присутствуют повторяющиеся символы) #
###############################################################################################


# поставив обратный слэш перед кавычками можно экранировать их
# тем самым вывести этот символ просто в качестве визуального элемента
# print("Я \"Иван\" всем привет!")
# print('Я "Иван" всем привет!')


# перенос строки на следующую строку (просто для оптимизации места на экране) (так же работает и для обычного кода)
# s = "qwerty\
# uiopa\
# sdfgh\
# jklzx\
# cvbnm"
# print(s)


# аналог переноса строки с помощью тройных кавчек (""", ''', ```)
# s = """qwerty
# uiopa
# sdfgh
# jklzx
# cvbnm"""
# print(s)


# строки могут сами конкатенироватся даже без '+'
# a = 'первый ' 'второй '   'третий'
# print(a)
# b = ('четвёртый '
#      'пятый '
#      'шестой')
# print(b)


# \n позволяет переносить строку на следующую по настоящему

# экранирование переноса строки изза \n с помощью второго слэша
# x = "https:\www.youtube.com\nexttab"
# x = "https:\www.youtube.com\\nexttab"

# специальный символ r перед строкой запрещает применять управляющие символы в данной строке
# x = r"https:\www.youtube.com\nexttab"
# для работы с путями в виндовс можно использовать r либо везде ставить двойной слэш
# x = 'C:\\Users\\PyHS\\Desktop'
# print(x)


# print('\f \v') # гендерные символы

# print('123\r456') # \r возврат в начало текущей строки
# print('123\b\b456') # \b возврат на один символ назад в текущей строке

# Сравнение строк
# print('abc' > 'r') # Получим False т.к. сравнение начинается с 1 символа а 'r' имеет больший порядковый номер чем 'a'
# print(ord('a'), ord('r'), ord('2'), ord('7')) # функция ord позволяет узнать номер символа в таблице ASCII
# print(chr(ord('a')), chr(ord('r'))) # функция chr наоборот переводит номер символа в сам символ
# print('abc' < 'abcd') # если символы в строках одинаковые но одна строка длиннее другой то True будет на стороне более длинной строки

# s = "stroka texta"
# print(s[5]) # получаем конкретный символ по индексу
# print(s[2:6]) # срез строки со 2 по 6 символ
# print(s[3:]) # срез с левой стороны
# print(s[:9]) # срез с правой стороны
# print(s[::2]) # срез символов через символ
# print(s[::-1]) # инвертируем строку с помощью среза

# инвертируем строку любой длинны с помощью цикла
# cat = 'Кошка'
# tac_table = []
# count = 0
#
# for letter in range(0, len(cat)):
#     count -= 1
#     tac_table.append(cat[count])
#
# inverseCat = ''.join(tac_table)
# print(inverseCat)


#######################################
# Методы для работы со строками (str) #
#######################################

s = 'Привет мир! Как дела народ?'
# уточнение для методов (find, rindex, count) индексация всегда идёт слева на право
# если указанного символа нет в тексте (find вернёт -1)(index вернёт ValueError)(count вернёт 0)
# (find, index, count) могут принимать доп арг. start, stop с какого и до какого индекса
# print(s.find('д')) # возвращает индекс первого попавшегося искомого символа либо строки из нескольких символов # метод rfind() ищет первый попавшийся символ справа на лево
# print(s.rindex('д')) # идентично с find просто может сыпать разные эрроры # rindex()
# print(s.count('д')) # узнать количество определенных символов
# print(len(s)) # узнать количество всех символов в строке
# print(s.upper()) # переводит все символы в верхний регистр
# print(s.lower()) # переводит все символы в нижний регистр
# print('a'.isupper(), 'A'.islower()) # проверит принадлежит ли символ к проверяемому регистру, вернёт булевое значение
# print('a'.swapcase(), 'A'.swapcase()) # меняет регистр на противоположный (переводит символы верхнего регистра в нижний регистр, а символы нижнего регистра в верхний регистр)
# print(s.capitalize()) # переводит первую букву в строке в верхний регистр а все остальные в нижний регистр
# print(s.title()) # переводит первую букву во всех словах в строке в верхний регистр
# print(s.istitle()) # если в строке большая буква только первая возвращает True иначе False
# print(s.strip()) # по дефолту удаляет неограниченное количество пробелов и преносов строк в начале и конце строки
# если указать символ он сделает тоже самое только с ним. Ещё методы которые убирают только с левой либо с правой стороны (lstrip, rstrip)
# print(s.isalpha()) # если символы являются только буквами возвращает True, иначе False
# print(s.isdigit()) # если символы являются только числами возвращает True, иначе False
# print(s.isalnum()) # если строка состоит из букв либо цифр или из букв вместе цифрами возвращает True иначе False
# print(s.replace('е', ' ^_^', 1)) # заменяет выбранный символ на другой, может принимать 3 арг. сколько замен надо произвести
# print(s.split('а')) # разделяет строку на сектора по выбранному символу и возвращает их в виде списка (по умолчанию по пробелам)
# print('111'.rjust(7, '$')) # вставляет символ заполнитель слева от строки # ljust аналогично только справа (по умолчанию заполн. пробел)
# print('abcd'.startswith('ab'), 'abcd'.startswith('ba')) # сравнивает указанный префикс с началом строки возвращает True если префикс совпадает
# print('abcd'.endswith('cd'), 'abcd'.endswith('dc')) # сравнивает указанный префикс с концом строки возвращает True если префикс совпадает

# print(reversed('98765')) # создаёт итератор с инвертированными элементами
# print(''.join(list(reversed('98765')))) # пример

# print(repr("строка вместе с одинарными кавычками\n\nЭ")) # возвращает строку вместе с кавычками и управляющими знаками

# функцию max и min можно использовать и для вычисления самой длинной строки передав в аргумент key функцию len
# print(max('aa', 'aaa', key=len))
# print(min('aa', 'aaa', key=len))


# либо даже так, возвращаем ключ максимального значения из словаря:
# from collections import Counter
# print(max(Counter([2,2,1,1,1,2,2]).items(), key=lambda tuple: tuple[1])[0])


# так же max можно использовать для сравнения строк, функция будет взвращать <class 'str'>
# сравнение происходит по номеру каждого символа слево на право по таблице ASCII
# print(max(['111', '444', '333']), type(max(['111', '444', '333'])))
# print(ord('1'), ord('4'), ord('3'))
#
# print(max("a", "б"))

# print(sorted(s)) # возвращает новый отсортированный список в переменную (родительский не трогает)

# print(sorted(s, key=str.lower)) # может принимать в качестве key методы сортируемого объекта в данном случае строки

# a = ['ZZZ 800', 'aaa 45', 'eee 43', 'DDD 800', 'BBB 43', 'www 14']
# # сортировка чисел в строке по возврастанию, сортировка букв по алфавиту без учёта регистра
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower())))
# # тоже самое только сортировка чисел по убыванию с помощью -int
# print(sorted(a, key=lambda x: (-int(x.split()[1]), x.split()[0].lower())))
# # тоже самое только сортировка как чисел так и букв по убыванию с помощью аргумента reverse
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower()), reverse=True))

# исключение(фильтрация) элементов последовательности по условию в переданной функции
# print(list(filter(lambda x: x > 4, [1, 2, 3, 4, 5, 6, 7])))

# reduce() применяет функцию к элементам последовательности, сводя ее к единственному значению
# from functools import reduce
# data = {"a": { "b": { "c": { "mykey": "myvalue"}}}}
# print(reduce(dict.get, ["a", "b", "c", "mykey"], data))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4]))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4], 7)) # третий арг. добавится к итоговому результату
#


# класс map принимает итерируемую последовательность вторым аргументом и функцию первым
# через которую будет прогонятся каждый элемент этой последовательности
# на выходе мы получим итератор с результатом выполнения по которому можно пройтись циклом либо просто обернуть в класс list()
# x = [0, 1, -10, 5, -8, 3]
# print(list(map(abs, x)))

# класс map совместно с методом split позволяет принимать аргументы от функции input
# написанные через пробел и преобразовывать их в другой тип
# n1, n2, n3 = map(int, input('Введите три числа через пробел: ').split()) # 1 2 3
# print('числа:', n1, n2, n3)
# n4, n5, n6 = map(str, input('Введите три буквы через пробел: ').split()) # a b c
# print('буквы:', n4, n5, n6)

# вместо int/str можно предать свою функцию или методы
# n00, n01, n02 = map(str.upper, ['hello', 'hi', 'good morning'])
# print(n00, n01, n02)

# аналогичный код функции map()
# n7, n8, n9 = [int(x) for x in input('Введите три числа через пробел: ').split()]
# print('числа:', n7, n8, n9)
# n10, n11, n12 = [str(x) for x in input('Введите три буквы через пробел: ').split()]
# print('буквы:', n10, n11, n12)

# метод строк translate позволяет заменить некоторые знаки или удалить их
# в методе str.maketrans 1 и 2 арг. отвечает за то какой знак на какой заменять, 3 арг что удалить из строки
# с помощью метода punctuation из модуля string получаем строку со знаками пунктуации
# from string import punctuation
# print(s.translate(str.maketrans('', '', punctuation)))
# print(punctuation)


# английский алфавит и цифры
# import string
# letters = string.ascii_letters
# digits = string.digits
# print(letters, digits, "")

# алгоритм генерации русского алфавита
# letters = ''.join([chr(c) for c in range(ord('а'), ord('а')+6)] + [chr(ord('а')+33)] + [chr(c) for c in range(ord('а')+6, ord('а')+32)])
# print(letters)

# # добавление текста в строку при помощи кортежа и спец символа %s
# d = "Hello %s I am %s and im %s good" % ('Arseniy', 'Python', 'Чертовски')
# print(d)

# a = "Какой то текст %(count)d %(items)s" % {"count": 19, "items": {"my_key1": "my_value1", "my_key2": "my_value2"}}
# print(a)
# b = "Какой то текст %(my_key)s" % {"my_key": "my_value"}
# print(b)
# c = "Какой то текст %s" % "ещё текст"
# print(c)
# d = "Какое то число %d" % 174
# print(d)

# добавление текста в строку с помощью метода format() и спец символа {}
# в данном примере строки в методе format представляют из себя кортеж
# обращаясь по индексам к данному кортежу можно подставлять текст в любое место строки
# a = "Hello {0} I am {1} and im {2} good".format('Arseniy', 'Python', 'Чертовски')
# print(a)
# # в данном примере строки в методе format мы передали в качестве аргументов
# # соответственно в строку и нужно подставлять ключи этих аргументов
# x = "Hello {name} I am {lang} and im {phrase} good".format(name='Arseniy', lang='Python', phrase='Чертовски')
# print(x)

# третий вариант самый лучший с помощью спец символа f перед строкой и фигурных скобок в которых можно записывать всё что угодно
# name = 'Arseniy'
# print(f'Hello {name} I can do it in f-string {5*5}')
# print(f'{name=}') # с помощью знака = после переменной, получаем имя=значение


# print(f'{3.8 :.2f}') # Количество знаков после точки для дробного числа
# print(f'{1030.2 :,.2f}') # Разделитель для целого числа и количество знаков после точки для дробного числа
# print(f'{1120 :,d}') # Вывести целое число, если число больше 999 то ставится запятая в качестве разделителя
# print(f'{3.8 :.1%}') # Умножает значение на 100, позволяет задать количество знаков после точки и добавляет знак процента в конце
# print(f'{200 :b}') # Представление числа в двоичном коде
# s = 'abcdefgg'
# print(f'{s :.3s}') # Макс количество символов отображаемых в строке, обрезание происходит справа на лево

# a = ((1024*1024)*42) / 1024
# print(a)
# aa = f'{a :,.0f}'[-1]
# print(aa)


################################### Блок Строки закончен ###################################


# raise ValueError('текст') # оператор вызова исключения с кастомным текстом

# Обработка ошибок в пайтон

# while True:
#     # пробуем исполнить код, если нет ошибок то он исполняется здесь
#     try:
#         enter = float(input("Введите число: "))
#         print("\nИсполнение try")
#     # если тип ошибки ValueError выполняем такой код
#     # можно не прописывать определенную ошибку тогда except: исполниться при любой ошибке
#     except ValueError:
#         print("\nexcept ValueError")
#     # если тип ошибки ZeroDivisionError то выполняем другой код
#     except ZeroDivisionError:
#         print("\nexcept ZeroDivisionError")
#     # обработка нескольких исключений в одном блоке except
#     except (ValueError, ZeroDivisionError):
#         print("\nexcept ValueError, ZeroDivisionError")
#     # не обязательный оператор else он исполниться только если успешно выполнен блок try и не задействован блок except
#     else:
#         print("Исполнение else")
#     # не обязательный оператор finally он исполниться и при try и при except
#     finally:
#         print("Исполнение finally")


# Обрабатывая одно исключение, обрабатываются все исключения ниже по иерархии
# например обрабатывая исключение LookupError обрабатываются IndexError, KeyError


# поиск необходимого исключения в блоке except идёт сверху вниз,
# кто первый найдётся будь он даже родительским исключением и будет использован для обработки.
# try:
#     2 + '2'
# except ValueError:
#     print('except ValueError:')
# except TypeError:
#     print('except TypeError:')
# except Exception:
#     print('except Exception:')
#
# try:
#     2 + '2'
# except Exception:
#     print('except Exception:')
# except TypeError:
#     print('except TypeError:')

# # так же можно записывать сразу несколько видов исключений в одну конструкцию except в виде кортежа.
# try:
#     2 + '2'
# except (ValueError, TypeError):
#     print('except (ValueError, TypeError):')

# try:
#     try:
#         raise ValueError('сообщение об исключении')
#     except Exception as exc:
#         print("INNER try-except", exc)
#         # для того чтобы внешний блок узнал о исключении во внутреннем
#         # можно рерайзнуть исключение и оно попадёт во внешний блок
#         raise
# except Exception as exc:
#     print("OUTER try-except", exc)


# Иерархия встроенных классов исключений

# BaseException - базовое исключение, от которого берут начало все остальные.
#     SystemExit - исключение, порождаемое функцией sys.exit при выходе из программы.
#     KeyboardInterrupt - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
#     GeneratorExit - порождается при вызове метода close объекта generator.
#     Exception - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
#         StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов.
#         ArithmeticError - арифметическая ошибка.
#             FloatingPointError - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
#             OverflowError - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
#             ZeroDivisionError - деление на ноль.
#         AssertionError - выражение в функции assert ложно.
#         AttributeError - объект не имеет данного атрибута (значения или метода).
#         BufferError - операция, связанная с буфером, не может быть выполнена.
#         EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
#         ImportError - не удалось импортирование модуля или его атрибута.
#         LookupError - некорректный индекс или ключ.
#             IndexError - индекс не входит в диапазон элементов.
#             KeyError - несуществующий ключ (в словаре, множестве или другом объекте).
#         MemoryError - недостаточно памяти.
#         NameError - не найдено переменной с таким именем.
#             UnboundLocalError - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
#         OSError - ошибка, связанная с системой.
#             BlockingIOError
#             ChildProcessError - неудача при операции с дочерним процессом.
#             ConnectionError - базовый класс для исключений, связанных с подключениями.
#                 BrokenPipeError
#                 ConnectionAbortedError
#                 ConnectionRefusedError
#                 ConnectionResetError
#             FileExistsError - попытка создания файла или директории, которая уже существует.
#             FileNotFoundError - файл или директория не существует.
#             InterruptedError - системный вызов прерван входящим сигналом.
#             IsADirectoryError - ожидался файл, но это директория.
#             NotADirectoryError - ожидалась директория, но это файл.
#             PermissionError - не хватает прав доступа.
#             ProcessLookupError - указанного процесса не существует.
#             TimeoutError - закончилось время ожидания.
#         ReferenceError - попытка доступа к атрибуту со слабой ссылкой.
#         RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий.
#         NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
#         SyntaxError - синтаксическая ошибка.
#             IndentationError - неправильные отступы.
#                 TabError - смешивание в отступах табуляции и пробелов.
#         SystemError - внутренняя ошибка.
#         TypeError - операция применена к объекту несоответствующего типа.
#         ValueError - функция получает аргумент правильного типа, но некорректного значения.
#         UnicodeError - ошибка, связанная с кодированием / раскодированием unicode в строках.
#             UnicodeEncodeError - исключение, связанное с кодированием unicode.
#             UnicodeDecodeError - исключение, связанное с декодированием unicode.
#             UnicodeTranslateError - исключение, связанное с переводом unicode.
#         Warning - предупреждение.


#################### Команды терминала ####################

# проверяем версию пайтон # python -V
# проверяем версию пип # pip -V
# обновить пип # python -m pip install --upgrade pip

# установка новых либ # pip install имяЛибы
# установка определенной версии либы # pip intall имяЛибы==номерВерсии
# обновление установленных либ # pip install -U pip имяЛибы
# обновление установщика pip # c:\python3-8-9\python.exe -m pip install -U pip pip

# удаление установленных либ # pip uninstall имяЛибы -y
# удаление всех либ прописанных в файле requirements.txt с помощью команды # pip uninstall -r requirements.txt -y
# или # pip uninstall -r requirements.txt
# проверяем установленные либы в глобальном окружении # pip list

# Если pip выдаёт ошибку: Fatal error in launcher: Unable to create process using
# выполняем 3 команды по очереди (возможно поможет):
# python -m pip uninstall pip
# python -m ensurepip
# python -m pip install -U "pip<10"

# Если pip выдаёт ошибку: Fatal error in launcher: Unable to create process using
# возможно поможет удаление и создание нового виртуального окружения, если оно конечно используется

# проверяем установленные либы в виртуальном окружении # pip freeze
# если дропает ошибку: 'Fatal error in launcher: Unable to create process using' тогда: python -m pip freeze

# создаём текстовый файл с используемыми либами в проекте с виртуальным окружением # pip freeze > requirements.txt
# если дропает ошибку: 'Fatal error in launcher: Unable to create process using' тогда: python -m pip freeze > requirements.txt

# создаём текстовый файл с используемыми либами в глобальном окружении # pip list > C:/pyTraining/requirements.txt

# создаём виртуальное окружение # python -m venv venv
# виртуальное окружение необходимо для того что бы загружать в него либы необходимые для работы скрипта

# активация виртуального окружения # venv/Scripts/activate.bat
# деактивация виртуального окружения # venv/Scripts/deactivate.bat
# либо сочетание клавиш в vsCode # ctrl+shift+P # затем Python: Выбор интерпритатора

# установка либ с помощь файла зависимостей # pip install -r requirements.txt

#############
# Замыкания #
#############

# Замыкание функции это когда в неё передаётся значение и запоминается в ней для последующего вызова, затем возвращается функция обёртка
# def adder(first_value):
#
#     def inner(second_value):
#         return first_value + second_value
#
#     return inner
#
# # # сначала вызываем функцию 'def adder' она запоминает значение аргумента 'first_value'
# # # далее возвращаем функцию 'def inner' которая помещается в переменную 'f1' для последующего вызова
# f1 = adder(2)
# # # затем вызываем функцию 'def inner' содержащуюся в переменной 'f1' и передаём в неё значение 'second_value'
# # # далее 'first_value' складывается с 'second_value' и возвращается на распечатку
# print(f1(4))

##############
# Декораторы #
##############

from functools import wraps

# # декоратор это функция которая позволяет обернуть другую функцию в свой код при этом не трогая оригинальный код
# def decorator(func_name):
#     # декоратор @wraps нужен для того что бы __name__ и __doc__ отображали информацию о родительской функции а не об обёртке
#     @wraps(func_name)
#     def wrapper():
#         """Документация тестовой функции wrapper"""
#         print('Выполнился код декоратора перед вызовом родительской функции make()') # выполняем код декоратора
#         print('Аргумент func_name ==', func_name) # переданный аргумент представляет собой имя функции
#         func_name() # выполненяем функцию make()
#         print('Выполнился код декоратора после вызова родительской функции make()') # продолжаем выполнение кода декоратора
#     return wrapper # возвращаем имя обёртки. make = wrapper()
#
# # # как аргумент в функцию decorator передаётся имя функции make
# @decorator # make = decorator(make)
# def make():
#     """Документация тестовой функции make"""
#     print('Выполнился код внутри функции make()')
# print('Запускаем функцию make() под декоратором @decorator')
# make()
# print('Код выполнен.')
#
# print('\nИмя функции:', make.__name__)
# print('Документация функции:', make.__doc__)

# Можно записать декоратор с пробросом дополнительных аргументов, выглядеть это будет так,
# просто добавляется ещё один внешний декоратор с помощью которого и декорируется необходимая
# функция, аргументы передеанные в этот внешний декоратор при обёртывании и попадут в _args, _kwargs
# def outer_decor(*_args, **_kwargs):
#     def decorator(func):
#         def wrapper(*args, **kwargs):
#             print('аргументы переданные в outer_decor при обёртывании:', _args, _kwargs)
#             print('аргументы переданные в функцию function:', args, kwargs)
#             func(*args, **kwargs)
#             print(func(*args, **kwargs))
#         return wrapper
#     return decorator
#
# @outer_decor(1, 2, a=3, b=4)
# def function(text, num, key_word_key):
#     print(text, num, key_word_key)
#     return text, num, key_word_key
# function('abc', 777, key_word_key='key_word_value')


# тот же самый декоратор но без синтаксического сахара:
# def function(text, num, key_word_key):
#     pass
# function_outer_decor = outer_decor(1, 2, a=3, b=4)(function)
# function_outer_decor('abc', 777, key_word_key='key_word_value')
# можно даже записать в одну строку:
# outer_decor(1, 2, a=3, b=4)(function)('abc', 777, key_word_key='key_word_value')


#декоратор на высчитывание времени выполнения функции
# from datetime import datetime

# def decor(func):
#
#     def wrapper():
#         x = datetime.now()
#         func()
#         y = datetime.now()
#         print(y-x)
#
#     return wrapper
#
# @decor
# def qwe():
#     a = list(range(1000))
#     for i in a:
#         print(i+i)
#
# qwe()


# Декоратор который кэширует результат вычислений функции func_name
# и в случае повторного запроса с такими же входными данными
# не будет заного считать а вернёт кэшированный результат.

# cache = {}
#
# def decor_func(func):
#
#     def wrapper(*args, **kwargs):
#
#         if args in cache:
#             #print(f'return cache | {args=}')
#             return cache[args]
#
#         result = func(*args)
#
#         cache[args] = result
#         # cache.update({args:result}) # способ добавления пары в словарь с помощью метода update
#
#         #print(f'create cache | {args=}')
#
#         return result
#
#     return wrapper
#
#
# @decor_func
# def func(x):
#     print("Wait im calculating")
#     return x*x + 1
#
#
# print('return:', func(4), '  cache:', cache)
# print('return:', func(4), '  cache:', cache)
# print('return:', func(4), '  cache:', cache)
# print('return:', func(6), '  cache:', cache)
# print('return:', func(6), '  cache:', cache)


################################################################
# Генераторы списков, словарей, множеств и Выражение генератор #
################################################################





































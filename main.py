# типа данных в питоне

#изменяемые(mutable)
# print(type(   {1,2,"a"}  )) #  -> <class 'set'> множество
# print(type(   {"a":1, 2:"b"}   )) #  -> <class 'dict'> словарь
# print(type(   [1,2,"a"]   )) #  -> <class 'list'> список
#
# from array import array
#
# print(type(  array("l", [1,2,4])  )) #  -> <class 'array.array'> массив
#print(type(bytearray(3))) # -> <class 'bytearray'> массив байт

#неизменяемые (unmutable)
# print(type(   1   )) #  -> <class 'int'> Числа
# print(type(   "abc"   )) #  -> <class 'str'> строки
# print(type(   (1,2,"a")  )) #  -> <class 'tuple'> картеж
# print(type(   None  )) #  -> <class 'NoneType'> Нету данных
# print(type(   False  )) #  -> <class 'bool'> Логическое значение
# print(type(   3.4  )) #  -> <class 'float'> дробное число
# print(type(   2 + 4j  )) #  -> <class 'complex'> комплексное число
# print(type(   frozenset([1,2,"a"])  )) #  -> <class 'frozenset'> Неизменяемое множество
#print(type(   bytes(123)   )) #  -> <class 'bytes'> байты

#print(complex(1+3j)) #создание комплексного числа


#узнать id объекта
# print(id( "str" )) # -> 140735957027056
# print( id( (1,2,"a") ) ) # -> 2850657923840

#узнать адрес в памяти в шестнадцатиричном формате
# print(hex(id("str"))) # -> 0x7fffa4b9c8f0
# print(hex(id(123))) # -> 0x7fffa4cff268

# print("123 = ", bytes(123)) # преобразует объект в неизменяемую строку байтов
# print("Привет Мир! =", bytes('Привет Мир!', encoding='utf-8'))

# перевод int в бинарную строку
# print("123 =", bin(123)) # -> 0b1111011
# print("123 =", bin(123)[2:]) # -> 1111011


#изменяемый обект(id и место в памяти объекта всегда одинаковый)
# x = [1,4,"a"]
# print(id(x), x) # -> 1313106120704 [1, 4, 'a']
# x[1] = 6
# print(id(x), x) # -> 1313106120704 [1, 6, 'a']
# x.append("g")
# print(id(x), x) # -> 1313106120704 [1, 6, 'a', 'g']


#неизменяемый объект(любое действие с объектом меняем его id)
# str = "123"
# print(id(str), str) # -> 2866371710448 123
# str = str[:2] + "6"
# print(id(str), str) # -> 2866371710128 126
# str += "5"
# print(id(str), str) # -> 2866371710320 1265


# Области видимости объектов
#built-in # встроенные функции в интерпретаторе, для их использования не нужно импортировать модули, а так же операторы(зарезервированные слова)
#global #объекты доступные в пространтсве имён модуля
#local # объекты достпуные внутри функции
#nonlocal # объекты доступные из блока внешней функции(обёртки)

# def a():
#     ''' Документация функции a '''
#
# class b:
#     ''' Документация класса b '''
#
#     def my_method_only_my():
#         pass
#
# print("Имя объекта", a.__name__, b.__name__) # позволяет посмотреть имя объекта
# print("Документация объекта", a.__doc__, b.__doc__) # позволяет посмотреть документацию объекта
# print(help(a)) # позволяет посмотреть документацию объекта
# print(globals()) # показывает доступные объекты в пространстве имен модуля
# import math
# print(dir(math)) # позволяет узнать какие объекты содержаться в функции/модуле (без аргументов в текущем пространстве имен модуля)
# print(dir(a))
# print(__name__) # узнать какое состояние имеет переменная __name__ в текущем пространстве имен модуля


# print(callable(len), callable("str")) # проверяем является ли объект вызываемым -> True False

# print(locals()) # возвращает словарь с переменными и их значениями из текущей локальной области видимости в виде словаря(dict)

# проверить, относится ли объект к определенному типу данных

# print(isinstance('str', int)) # -> False
# print(isinstance('str', str)) # -> True
#
# #тоже самое, но с помощью type
#
# print(type('str') == int)
# print(type('str') == str)

#принадлежность объекта к определенному сабклассу можно проверить с помощью функции issubclass

# print(issubclass(int, type(72))) # -> True
# print(issubclass(int, type("Hello, world!"))) # -> False
# print(issubclass(str, type("Hello, world!"))) #-> True

#функция type определяет тип данных

# if type(True) == bool:
#     print("boolean")
# if type(1) == int:
#     print(type(1))

# функция bool преобразует число в True или False
#если число == 0 тогда ложь, если число меньше или больше 0 тогда истина
# print(bool(0))
# print(bool(1))
# print(bool(-1))

# так же и со строками, только вместо 0 принимается пустая строка
# print(bool(""))
# print(bool("123"))

#так же и с коллекциями
# print(bool([]))
# print(bool([1,3]))

#умножение разных типов данных
# print(1 * 5) # int -> 5
# print("1" * 5) # str -> "11111"
# print((1,) * 5) # tuple -> (1, 1, 1, 1, 1)
# print([1] * 5) # list -> [1, 1, 1, 1, 1]
# print([[]] * 5) # list -> [[], [], [], [], []]
# print(["1"] * 5) # list -> ['1', '1', '1', '1', '1']
# print(True*5, 1*5)
# print(False*5, 0*5)

# булевые значения можно сумировать если они сумируются в integer object
#         1     0      1     1
# array = [True, False, True, True]
# count = 0
# for i in array:
#     count += i
# print(count, sum(array)) # -> 3 3


# hash можно найти только у неизменяемых типов данных
# print(hash('str')) # -> 4271691589574039315
# print(hash([1,2,3])) # -> TypeError: unhashable type: 'list'

#код можно писать в 1 строку, с помощью ;
# x = 1; y = 2; z = 3
# print(x,y,z) # -> 1 2 3

# в принт можно добавить sep и пробелы между выводимыми объектами будут заменяться на другие символы
# print(1,2,3, sep='a') # -> 1a2a3

#так же можно задать параметр end тем самым убрать перенос строки
# print(1,2,3, end=" ")
# print(4,5,6) # -> 1 2 3 4 5 6


# читабельный вывод словарей с табуляцией
# import json
# print(json.dump(словарь, indent=4, ensure_ascii=False))

# метод str() переводит int в str
# a = 3
# b = 2.4
# c = 'str' + str(a) + str(b)
# print(c) # -> str32.4

#функция input запрашивает пользователя ввод значения с клавиатуры в консоль
#функция int переводит строковое значение(цифровое) в целое числовое
#функция float переводит строковое значение(цифровое) в число с палвающей точкой
# a = int(input("Введите число")) # <- 5
# b = int("5")
# c = float("2.4") + a + b
# print(c) # -> 12.4


# eval может лишь выполнить выражение python
# print(eval("100 + 101")) # -> 201
# print(eval("sum([10,3,23])")) # -> 36
# print(eval("[i for i in range(5)]")) # -> [0, 1, 2, 3, 4]

x,y = 5,5
# print(eval("x != y")) # -> False
# print(eval("x != y", {"x": 5})) # -> NameError: name 'y' is not defined. Если вторым аргументам в евал передавать словарь, то он будет видеть только переменные из словаря, в словаре можно переоьъявить глобальные пременные

# с помощью compile можно выражение занести в объект
# code = compile("4+5", "<string>", "eval")
# print(eval(code)) # -> 9

# с помощью exec() можно выполнить любой блок когда python
# exec("if 1 > 0: print('Yes 1 > 0')") # -> Yes 1 > 0

#операторы условий
# if
# elif
# else
# :
# pass # заглушка, нужна для того чтобы не писать print() после объявление условий или функции или ``` ```
# ... # работает так же как заглушка
# del # оператор удаление объекта

# логические операторы(имеют приоритет выполнение)
# not # 1
# and # 2
# or # 3

#contiune нужен для того, что бы пропускать итерацию цикла и начинать следующую с самого начала
# break оператор для работы с циклами, нужен для того, чтобы завершать цикл и выходить из тела цикла
# else  оператор для работы с циклами, сработает в том случае если все итерации цикла завершены

# i = 0
# print("==> IN")
# while i < 10:
# 	i += 1
# 	if 3 < i < 6:
# 		print("i=", i, "contiune")
# 		continue
# 	print("i=", i)
# 	if i == 8:
# 		print("i=", i, "break")
# 		break
# else:
# 	print("else worked")
# print("==> OUT")


# Убираем повторяющиеся элементы из списка с помощью цикла
# a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
# b = []
# for i in a:
# 	if not i in b:
# 		b.append(i)
# print(a)
# print(b)
# print(list(set(a))) # аналогичное решение задачи


# сортировка строки по маленьким/большим буквам и не буквенным символам с помощью цикла
# s = 'h@lLo WOrld!'
#
# for i in s:
# 	if "a" <= i <= "z":
# 		print(i, 'small')
# 	elif "A" <= i <= "Z":
# 		print(i, "BIG")
# 	else:
# 		print(i, "not word")


# подсчет повторяющихся символов в строке с помощью цикла
# x = 'frsncsIU$WB$Csfnsdfoisnfcweopfcfsdlfnweocgiroenc'
# result = {}
# for i in x:
# 	try:
# 		result[i] += 1
# 	except:
# 		result[i] = 1
# print(result)

# Операторы сравнений (Проверяют объекты на равенство их значений)
# ==
# <
# >
# <=
# >=
# !=

# построение диапазона значений

# x = 4
# if 2 <= x <= 10:
# 	print("х в диапазоне от 2 до 10")

# опеароты сравнений можно записать в цеопчкке
# x,y,z = 1,1,1
#
# if x == y == z:
# 	print("все числа равны")

# оператор in если объект совпадает хотя бы частично с другим объектов тогда выдает True
# x = "abc"
# y = "adcs"
# z = "abcd"
# print(x in z) # -> True
# print(y in z) # -> False

# оператор is если объекты ссылаются на одну и ту же ячейку памяти, тогда True
# x = 10
# y = int("10")
# print(x is y) # -> True


# для слишком больших чисел выделяется отдельная область в памяти
# x = 31**25
# y = 31**25
# print(x, x is y) # True
# a = 26**26
# b = 26**26
# print(a, a is b) # False


#для списков выделяется отдельная область в памяти
# x = [1,2,3]
# y = [1,2,3]
# z = x
# print(x is y) # -> False
# print(x is z) # -> True
# print(y is z) # -> False

# самое большое число в питоне float('inf'), он действует как неограниченное верхнее значение
# print(float('inf') > 99999999999**999999) # -> True


# Математические операторы (имеют приоритет выполнения)
# a = 10 + 5
# a = 10 - 5
# a = 10 * 5
# a = 19 / 5 # обычное деление, ответ = 3.8
# a = 19 // 5 # деление с отбросом остатка после точки (в числе 19 число 5 помещается 3 раза)
# Остаток от деления 19 % 7 в число 19 число семь помещается 2 раза, остаток = 5

#найти числа кратные 4
# for i in range(50):
#     if i % 4 == 0:
#         print(i)


#операции с числами

#функция sum() сумирует все числа в списке
# print(sum([1,2,3,4,5])) # -> 15

#функция abs() переводит число из отрицательного в положительное
# print(abs(-12)) # -> 12

#функция min() находит наименьшее число из списка
# print(min([2,4,6,2,1,0,-2,-54,-1])) # -> -54

#функция max() находит наибольшее число из списка
# print(max([2,4,6,2,1,0,-2,-54,-1])) # -> 6

#функция pow() возводит число в степень
# print(pow(5,5), 5**5) # -> 3125 3125

#функция round() округляет число в плавающей точкой в большую или меньшую сторону в зависимости куда ближе, так же можно вторым аргументом передать, сколько оставить цифр после запятой
# (round(5.6342)) # -> 6
# print(round(5.27234, 1)) # -> 5.3

import math
#функция math.ceil окргуляет число всегда в большую сторону
# print(math.ceil(5.3)) # -> 6

#функция math.floor окргуляет число всегда в меньшую сторону
# print(math.floor(5.9)) # -> 5

#функция math.trunc убирает цифры после точки, работает аналогично int()
# print(math.trunc(5.7)) # -> 5

#math.pi - число pi
# print(math.pi) # -> 3.141592653589793

#разделение числа по цифрам c помощью математических операторов
# x=3456
#
# n1 = x // 1000
# n2 = x // 100 % 10
# n3 = x // 10 % 10
# n4 = x % 10
# print(n1, n2 ,n3 ,n4)

#программа открывающая сайт
# import os
# while True:
#     sait = input()
#     if "https://" in sait:
#         os.system("start " + sait)
#         break

#модуль рандом
# import random
# for i in range(20):
#     print(random.randrange(1, 100))

# while оператор цикла исполняется (пока условие верно)
# цикл от 1 до 5
# можно подключить оператор else который сработает по завершению цикла
# a = 0
# while a < 5 :
# 	a += 1
# 	print(a)
# else :
# 	print("finish")

#цикл for
# x = [1,2,3,4,5,6]
# for i in x[3:]:
#     print(i) # -> 4 5 6

# итерация элементов в итерируемом объекте с помощью функций iter() next()
# x = range(5)
# print(x, type(x)) # -> range(0, 5) <class 'range'>
#
# it = iter(x)
# it = x.__iter__() # тоже самое - другая запись
# print(it, type(it))
#
# n1 = next(it)
# n2 = it.__next__()
# n3 = next(it)
# n4 = next(it)
# n5 = next(it)
# print(n1,n2,n3,n4,n5) # -> 0 1 2 3 4

# если элементы закончились и еще раз прописать next() то выйдет исключение StopIteration


# функция zip() упаковывает элементы из 2-х списков в кортеж, [ (a[0], b[0]) , (a[1], b[1]) ]
# a = [5,6,7]
# b = [100,200,300, 400]
#
# zp = zip(a,b)
# print(zp,type(zp), list(zp)) # -> <zip object at 0x000001A662F94D40> <class 'zip'> [(5, 100), (6, 200), (7, 300)]


#########################################################################################
# Список (list) упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#########################################################################################

# индексация с конца            -4              -3                -2               -1
# индексация с начала            0               1                 2                3
# x = [1,2,3,'abc', [123,123,321], (1,3,5)]
#
# #узнать длины списка можно с помощью функции len()
# print(x[0], len(x)) # -> 1 6
#
# #без исключения обратиться к последнему элементу списка(если он пустой)
# # lst = []
# # x = lst[-1:] or None
# # print(x)
#
# #можно обращаться ко вложенным списка
# print(x[4][0]) # -> 123
#
# #можно перезаписывать определенную ячейку списка
# x[0] = 5
# print(x)
#
# #можно менять переменные местами множественным присваиванием
# x[0], x[2] = x[2], x[0]
# print(x)
#
# #можно добавить данные в список
# x = x + [[1,2,3]]
# print(x)

#функция list() разбивает строку по 1-му символу в лист
# x = list("abcdfsdf")
# print(x)

# сравнение списков (при этом происходит поочередное сравнение каждого элемента списка слева на право)
# print('[1] <= [1]', [1] <= [1]) # -> True
# print('[2] <= [1]', [2] <= [1]) # -> False
# print('[1, 1] <= [1, 1]', [1, 1] <= [1, 1]) # -> True
# print('[1, 2] <= [1, 1]', [1, 2] <= [1, 1]) # -> False

#методы для работы со списками

# x = [1,2,3,4,5]
# #узнаем есть ли значение в промежутке списка от 1 до 4
# print(3 in x[1:4]) # -> True
#
# #узнать длины списка можно с помощью функции len()
# print(len(x)) # -> 5
#
# # .append() добавляет элемент в конец списка
# # x.append("qwe")
# # print(x) # -> [1, 2, 3, 4, 5, 'qwe']
#
# # .insert() вставляет элемент в указанный индекс
# # x.insert(0, "5")
# # print(x) # -> ['5', 1, 2, 3, 4, 5, 'qwe']
#
# # .count() подсчитывает сколько одинаковых элементов в списке по значению
# print(x.count(5)) # -> 1
#
# # .index() узнаем индекс элемента по его имени
# print(x.index(5)) # -> 5 (2 arg = с какого индекса начать поиск 3arg = до какого индекса искать)
#
# # .sort() сортирует список по возрастанию, если добавить reverse=True список отсортируется по убыванию
# # так же есть 2 аргумент key=func, чтобы менять принцип сортировки
# x.sort(reverse=True)
# print(x) # -> [5, 4, 3, 2, 1]
# c = sorted(x, key=abs) # возвращает новый отсортированый список, не трогая родительский
# print(c) # -> [1, 2, 3, 4, 5]
#
# # .reverse() инвертирует список и перезаписывает его в ту же ячейку памяти
# print("1:", x)
# x.reverse()
# print("2:", x)
#
# #reversed() создает итератор с инвертированными элементами
# # (аналогично x = list('98765') x.reverse() print(x))
# print(reversed("74452"))
#
# # .pop удаляет элемент по указанному индексу (если указать переменную, то сохранит удаленный элемент в переменную)(без аргументов удаляет элемент в конце списка)
# xd = x.pop(0)
# print(x, xd) # -> [2, 3, 4, 5] 1
#
# # .remove() удаляет элемент по его имени
# x.remove(2)
# print(x) # -> [3, 4, 5]
#
# # .clear() полностью очищает список
# x.clear()
# print(x) # -> []
#
# # .extend() распаковывает список в конец списка
# x.extend(["123", 'wp', 123])
# print(x) # -> ['123', 'wp', 123]
#
# # .copy() копирует список в переменную
# xc = x.copy()
# print(xc) # -> ['123', 'wp', 123]
# #analog
# xc1 = x[:]
# xc2 = list(x)
# print(xc1, xc2) # -> ['123', 'wp', 123] ['123', 'wp', 123]
#
# #списки можно складывать
# x = ['Hello']+['world']+['!']
# print(x) # -> ['Hello', 'world', '!']
#
# #переводим список обратно в строку
# text = '_'.join(x)
# print(text) # -> Hello_world_!

# a = list(range(10))
# b = []
# for i in a:
#     if i == (5 or 6):
#         continue
#     b.append(i)
# else:
#     print(b)
#
# # в списках можно использовать срезы, также как и в строках
#
# #если нам нужно скопировать список, то используем метод copy()
# c = a.copy()
# #либо более точное средство(синтаксис срезов)[start:stop:step]
# c = a[::] # -> [0, 1, 2, 3, 4, 6, 7, 8, 9]
# #заменяем цикл одной строчкой
# c = a[0::2] # получаем только нечетные индексы # -> [0,2,4,6,8]
# c = a[1::2] # получаем только четные индексы # -> [1,3,5,7,9]
# c = a[:5] # получаем список до 5 индекса включительно # -> [0,1,2,3,4]
#
# # заменяем первые 2 элемента на значения из нового списка
# c[:2] = ["a", "b"] # -> ['a', 'b', 2, 3, 4]
#
# # удалить значение по индексы
# del c[2] # -> ['a', 'b', 3, 4]
# print(c)
#
# # удаляем из списка все четне числа и заносим их в новый список
#
# for i in a:
#     if i % 2 == 0:
#         a.remove(i)
#         b.append(i)
# else:
#     print(a, b)


#######################################################################################################
# Кортеж (tuple) неизменяемая упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#######################################################################################################

# создание кортежа без помощи круглых скобок с одним значением и запятой
# x = 1,
# print(x, type(x))

#создание кортежа, скобки дают наглядное представление, что это кортеж
# x = (1,2,3)
# print(x)
#присвоение значений из кортежа в переменные
# a,b,c = x
# print(a,b,c)

# создание пустого кортежа
# x = ()
# print(x)
# x = tuple() # аналог
# print(x)

#для создание кортежа можно использовать любую итерабельную последовательность
# print(tuple([1,2,3]), tuple({"a":1, "b":2}), tuple({1,2,3}), tuple((1,2,3)), tuple("123"), tuple(range(3))) # -> (1, 2, 3) ('a', 'b') (1, 2, 3) (1, 2, 3) ('1', '2', '3') (0, 1, 2)

#кортеж имеет индексацию по аналогии со списками
# x = tuple(range(4))
# print(x[2])


#хоть кортеж и является не изменным, но если в нем содержится изменяемый тип данных, то мы можем изменить его
# x = (1,2,[1,2])
# x[2].append(2)
# print(x) # -> (1, 2, [1, 2, 2])

#кортеж можно использовать в качестве ключа для словаря
# x = 1,2,3
# b = {}
# b[x] = 123
# print(b) # -> {(1, 2, 3): 123}

#у кортежа очень мало методов, поэтому можно преобразовать его в список - изменить - преобразовать обратно
# x = (1,2,3,4,5,6)
# x1 = list(x)
# x1[0] = -1
# x1.append(7)
# x2 = tuple(x1)
# print(x2) # -> (-1, 2, 3, 4, 5, 6, 7)

#обращение к элементу кортежа по индексу
# x = ("i", "love", "u")
# print(x[1]) # -> love

#к кортежу можно применять срез
# x = (1,2,3,4,5,6)
# # print(x[1:3]) # -> (2, 3)

#кортежи можно складывать
# x = (1,2)
# x1 = (3,4,5,6)
# print(x + x1) # -> (1, 2, 3, 4, 5, 6)

#кортежи можно умножать
# x = (1,2,3)
# print(x * 2) # -> (1, 2, 3, 1, 2, 3)

#с помощью in можно проверить находится ли объект в кортеже
# x = ('a', 'b', 'c')
# print( 'a' in x , 'n' in x ) # -> True False

#функция enuerate превращает каждый элемент в кортеж, состоязий из индекса и значение
#может принимать 2арг, в котором указывается, с какого индекса начинать
# print(list(enumerate([1,2,3,4,5], 111))) # -> [(111, 1), (112, 2), (113, 3), (114, 4), (115, 5)]

# dct = {"111": 10, "112": 11}
# for index, value in enumerate(dct):
#     print(index, value) # -> 0 111, 1 112

#########################################
# Методы для работы с кортежами (tuple) #
#########################################
# x = (1,2,3,4,5)
#
# print(len(x)) # -> 5
# print(x.count(1)) # -> 1
# print(x.index(4)) # -> 3
# print(sorted(x, reverse=True)) # -> [5,4,3,2,1]

################################### Блок Кортежа закончен ###################################

######################
# Работа с функциями #
######################

#функция определения каллорийности

# def calorie_calculate(name, get_calorie, spend_calorie):
#     if get_calorie > spend_calorie:
#         msg = name + " getting fat"
#     else:
#         msg = name + " lose weight"
#     return msg

# print(calorie_calculate("Ivan", 1200, 1300)) # -> Ivan lose weight
# persone = ["Slava", 1300, 1200]
# #в функцию можно передавать список со значениями, указав * перед списком
# print(calorie_calculate(*persone)) # -> Slava getting fat


#return возвращает значени в точку запуска функции name_func()
#
# def qwe():
#     x = 2 + z
#     return x
#
# z = 3
# #переменные должны объявляться выше вызываемой функции связанной с этими переменными
# y = qwe()
# print(y) # -> 5
# #взаимодейстовать с переменной x можно только через return
# y = qwe() + 1
# print(y) # -> 6

# в функцие можно указывать дефолтные аргументы и давать им значения
# def count_list(list, boolean = False, count = 0):
#     if boolean == True:
#         typelist = type(list[5]) # узнаем тип элемента списка
#         for i in list:
#            count += 1 #узнаем сколько элементов в списке
#         return count, typelist
#     else:
#         for i in list:
#             count += 1
#         return count
#
# j = [9, 8, 7, 6, "a", 0.4, True]
# h,p = count_list(j, True)
# print(h,p) # -> 7 <class 'float'>

# если нужно распокавать больше значений чем переменных, тогда остальные значение попадут в переменную-лист со *
# *x, y, z = 2, 3
# # print(x,y,z) # -> [] 2 3
# #
# # x, *y, z = 2,3
# # print(x,y,z) # -> 2 [] 3
# #
# # x,y, *z = 2,3
# # print(x,y,z) # -> 2 3 []
# #
# # *x, y, z = 1 ,2,3,4,5,6,7,8
# # print(x,y,z) # -> [1, 2, 3, 4, 5, 6] 7 8

#если перед аргументом поставить * то все аргумента после него превратяться в кортеж, можно записать аргументы после кортежа, если указать в вызове имя аргумента и значение

# def name(h,d, *args, key1, key2):
#     print(h) # -> 1
#     print(d) # -> 2
#     print(args) # -> (3,4,5)
#     print(key1) # -> 6
#     print(key2) # -> 7
#
# name(1,2,3,4,5,key1=6, key2=7)

#функция возвращает по 1 элементы без повторений
# def exclusive_item(*args, key=True):
#     newlist = []
#     for i in args:
#         for y in i:
#             if y not in newlist:
#                 newlist.append(y)
#     if key:
#         newlist.sort()
#     return newlist
#
# print(exclusive_item([3,1,5,7,2,4,2])) # -> [1, 2, 3, 4, 5, 7]


#args=arguments
# def print_ab(a,b, *args):
#     print(a)
#     print(b)
#     print(args)
#
# #передача списка спомощью спец. символа * разбивает его поэлементно и отправляет каждый элемент в виде отдельного аргумента
# x = [1,2,3,4,5,6,7]
# print_ab(*x) 1 2 (3, 4, 5, 6, 7)
# # Если не угадать с количеством передаваемых элементов и объявленых аргументов в функции
# # то получим исключение TypeError, что бы не прописывать каждый аргумент в функции, можно
# # воспользоваться спец символом * уже в функции для включения всех полученных элементов в один кортеж

#kwargs = keyword arguments
# # если между позиционными a, b и запакованными **kwargs стоит слеш то аргументы из **kwargs автоматически не перейдут в a, b
# def print_ab2(a, b, /,**kwargs):
#     print(a)
#     print(b)
#     print(kwargs)
#
# #таким же способ можно передавать с помощью * ключи словаря, а с помощью ** значения словаря
# dct = {'a':10, 'b':20, 'c':30, 'd':40}
# print_ab2(**dct)
# print_ab2(1, 2, c=10, d=20)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#перезаписываем элементы которые объявлены вне функции с помощью global
# x = 5
# def qwe():
#     global x
#     x = 10
# print(x) # -> 5
# qwe()
# print(x) # -> 10

#аналог global но можно использовать только во вложенной функции nonlocal

# x = 5
# def qwe():
#     x=10
#     print(x) # -> 10
#     def qwe1():
#         nonlocal x
#         x = 15
#         print(x) # -> 15
#     qwe1()
#     print(x) # -> 15
# print(x) # -> 5
# qwe()
# print(x) # -> 5















